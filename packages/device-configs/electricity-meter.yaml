---
# Electric Meter Package - Generic OBIS smart meter support
# 
# IMPORTANT: This package requires custom components (uart_line_reader and deduplicate_text).
# You must include this in your main configuration:
# external_components:
#   - source:
#       type: local
#       path: components
# 
# Requires the following substitutions to be defined in the main configuration:
#
# UART Configuration:
#   uart_rx_pin: GPIO pin for UART RX (e.g., "D2")
#   uart_baud_rate: UART baud rate (e.g., "9600")
#   uart_parity: UART parity (e.g., "EVEN" or "NONE")
#   uart_data_bits: UART data bits (e.g., "7" or "8")
#   uart_stop_bits: UART stop bits (e.g., "1")
#   uart_rx_buffer_size: UART RX buffer size (e.g., "1024")
#
# OBIS Codes:
#   obis_total_consumption: Total energy consumption OBIS code
#   obis_consumption_1d: 1-day consumption OBIS code
#   obis_consumption_7d: 7-day consumption OBIS code
#   obis_consumption_30d: 30-day consumption OBIS code
#   obis_consumption_365d: 365-day consumption OBIS code
#   obis_current_power: Current power OBIS code
#   obis_consumption_t1: T1 consumption OBIS code
#   obis_consumption_t2: T2 consumption OBIS code
#   obis_voltage_l1: L1 voltage OBIS code
#   obis_voltage_l2: L2 voltage OBIS code
#   obis_voltage_l3: L3 voltage OBIS code
#   obis_current_l1: L1 current OBIS code
#   obis_current_l2: L2 current OBIS code
#   obis_current_l3: L3 current OBIS code
#   obis_frequency: Frequency OBIS code
#   obis_phase_angle_ul2_ul1: Phase angle UL2:UL1 OBIS code
#   obis_phase_angle_ul3_ul1: Phase angle UL3:UL1 OBIS code
#   obis_phase_angle_il1_ul1: Phase angle IL1:UL1 OBIS code
#   obis_phase_angle_il2_ul2: Phase angle IL2:UL2 OBIS code
#   obis_phase_angle_il3_ul3: Phase angle IL3:UL3 OBIS code
#   obis_serial_number: Serial number OBIS code
#   obis_firmware_version: Firmware version OBIS code
#   obis_parameter_crc: Parameter CRC OBIS code
#   obis_status_register: Status register OBIS code
#   obis_consumption_since_reset: Consumption since reset OBIS code
#
# Validation Constants:
#   max_power_change: Maximum power change per reading (e.g., "3000.0")
#   max_current_change: Maximum current change per reading (e.g., "13.0")
#   max_energy_change: Maximum energy change per reading (e.g., "1.0")
#   max_rolling_energy_change: Maximum energy change for rolling window sensors per reading (e.g., "2.0")
#   max_energy_total: Maximum total energy value (e.g., "100000.0")
#   max_absolute_power: Maximum absolute power value (e.g., "34500.0")
#   min_energy_value: Minimum energy value (e.g., "0.0")
#   min_power_value: Minimum power value (e.g., "0.0")
#   max_voltage: Maximum voltage value (e.g., "280.0")
#   min_voltage: Minimum voltage value (e.g., "0.0")
#   max_current: Maximum current value (e.g., "30.0")
#   min_current: Minimum current value (e.g., "0.0")
#   max_frequency: Maximum frequency value (e.g., "52.0")
#   min_frequency: Minimum frequency value (e.g., "48.0")
#   max_phase_angle: Maximum phase angle value (e.g., "360.0")
#   min_phase_angle: Minimum phase angle value (e.g., "-360.0")
#
# Rolling Window Maximum Values:
#   max_consumption_1d: Maximum consumption for 1-day rolling window (e.g., "30.0")
#   max_consumption_7d: Maximum consumption for 7-day rolling window (e.g., "210.0")
#   max_consumption_30d: Maximum consumption for 30-day rolling window (e.g., "800.0")
#   max_consumption_365d: Maximum consumption for 365-day rolling window (e.g., "10000.0")

# UART for IR head communication
# Note: This package requires a custom uart_line_reader component
# Add this to your main configuration:
# external_components:
#   - source:
#       type: local
#       path: components
uart:
  rx_pin: ${uart_rx_pin}
  baud_rate: ${uart_baud_rate}
  id: uart_bus
  parity: ${uart_parity}
  data_bits: ${uart_data_bits}
  stop_bits: ${uart_stop_bits}
  rx_buffer_size: ${uart_rx_buffer_size}

# Global variables for validation state tracking
globals:
  - id: prev_total_consumption
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_1d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_7d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_30d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_365d
    type: float
    initial_value: "-1.0"
  - id: prev_current_power
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_t1
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_t2
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_since_reset
    type: float
    initial_value: "-1.0"
  - id: prev_current_l1
    type: float
    initial_value: "-1.0"
  - id: prev_current_l2
    type: float
    initial_value: "-1.0"
  - id: prev_current_l3
    type: float
    initial_value: "-1.0"
  - id: total_frames_received
    type: uint32_t
    initial_value: "0"
  - id: corruption_count
    type: uint32_t
    initial_value: "0"
  - id: serial_number_last_hash
    type: uint32_t
    initial_value: "0"
  - id: serial_number_count
    type: int
    initial_value: "0"
  - id: firmware_version_last_hash
    type: uint32_t
    initial_value: "0"
  - id: firmware_version_count
    type: int
    initial_value: "0"
  - id: parameter_crc_last_hash
    type: uint32_t
    initial_value: "0"
  - id: parameter_crc_count
    type: int
    initial_value: "0"
  - id: status_register_last_hash
    type: uint32_t
    initial_value: "0"
  - id: status_register_count
    type: int
    initial_value: "0"

# OBIS data parsing text sensor
text_sensor:
  - platform: uart_line_reader
    uart_id: uart_bus
    name: "OBIS Raw Line"
    id: obis_raw_line
    internal: true
    filters:
      - lambda: |-
          if (x.length() < 10) return {};
          if (x[0] != '0' && x[0] != '1') return {};
          if (x.find('*') == std::string::npos ||
              x.find('(') == std::string::npos ||
              x.find(')') == std::string::npos) return {};
          return x;
    on_value:
      then:
        - lambda: |-
            #include <errno.h>
            // Track OBIS telegram processing for quality metrics
            id(total_frames_received)++;

            // Flag to track if corruption occurred in this telegram
            bool telegram_corrupted = false;

            // Validation constants from substitutions
            const float MAX_POWER_CHANGE = ${max_power_change};
            const float MAX_CURRENT_CHANGE = ${max_current_change};
            const float MAX_ENERGY_CHANGE = ${max_energy_change};
            const float MAX_ROLLING_ENERGY_CHANGE = ${max_rolling_energy_change};
            
            // Range validation constants
            const float MIN_ENERGY_VALUE = ${min_energy_value};
            const float MAX_ENERGY_TOTAL = ${max_energy_total};
            const float MAX_CONSUMPTION_1D = ${max_consumption_1d};
            const float MAX_CONSUMPTION_7D = ${max_consumption_7d};
            const float MAX_CONSUMPTION_30D = ${max_consumption_30d};
            const float MAX_CONSUMPTION_365D = ${max_consumption_365d};
            const float MIN_POWER_VALUE = ${min_power_value};
            const float MAX_ABSOLUTE_POWER = ${max_absolute_power};
            const float MIN_VOLTAGE = ${min_voltage};
            const float MAX_VOLTAGE = ${max_voltage};
            const float MIN_CURRENT = ${min_current};
            const float MAX_CURRENT = ${max_current};
            const float MIN_FREQUENCY = ${min_frequency};
            const float MAX_FREQUENCY = ${max_frequency};
            const float MIN_PHASE_ANGLE = ${min_phase_angle};
            const float MAX_PHASE_ANGLE = ${max_phase_angle};
            
            // Helper to trim strings to 30 chars without allocation
            // Uses thread-local storage for cross-platform safety (ESP8266/ESP32)
            auto trim_for_log = [](const std::string &str) -> const char* {
              thread_local char buf[31];  // Thread-local storage - safe on both platforms
              size_t len = std::min(str.length(), size_t(30));
              memcpy(buf, str.c_str(), len);
              buf[len] = '\0';
              return buf;
            };

            // Helper to trim string_view to 30 chars without allocation
            auto trim_sv_for_log = [](std::string_view sv) -> const char* {
              thread_local char buf[31];  // Thread-local storage - safe on both platforms
              size_t len = std::min(sv.length(), size_t(30));
              memcpy(buf, sv.data(), len);
              buf[len] = '\0';
              return buf;
            };
            
            // Use ESPHome's built-in parse_number function - causes dynamic memory allocation undesirable for ESP8266
            // auto parse_float = [](const std::string &str) -> float {
            //   auto n = parse_number<float>(str);
            //   return n.has_value() ? n.value() : NAN;
            
            // Lightweight helper: parse float from a std::string_view without heap allocations
            auto parse_float = [](std::string_view sv) -> float {
              if (sv.empty()) return NAN;
              char buf[32];
              size_t len = std::min(sv.size(), sizeof(buf) - 1);
              memcpy(buf, sv.data(), len);
              buf[len] = '\0';

              char *endptr = nullptr;
              errno = 0;  // Clear errno before strtof
              float val = strtof(buf, &endptr);
              // Check for parsing errors: no characters processed, extra junk, or errno set
              if (endptr == buf || *endptr != '\0' || errno != 0) {
                return NAN;
              }
              return val;
            };

            // FNV-1a hash function for string_view - memory-efficient duplicate detection
            auto calculate_hash = [](std::string_view sv) -> uint32_t {
              uint32_t hash = 2166136261U;  // FNV-1a 32-bit offset basis
              for (char c : sv) {
                hash ^= static_cast<uint32_t>(c);
                hash *= 16777619U;  // FNV-1a 32-bit prime
              }
              return hash;
            };

            // Parse OBIS string value from line, returned as string_view to avoid allocations
            auto parse_obis_string_value = [&](const std::string &line, const std::string &obis, char delimiter) -> std::string_view {
              size_t pos = line.find(obis);
              if (pos == std::string::npos) {
                return {};
              }

              size_t start = line.find('(', pos);
              if (start == std::string::npos) {
                ESP_LOGW("meter", "No '(' for %s", trim_for_log(obis));
                telegram_corrupted = true;
                return {};
              }

              size_t end = line.find(delimiter, start);
              if (end == std::string::npos || end <= start) {
                ESP_LOGW("meter", "No '%c' for %s", delimiter, trim_for_log(obis));
                telegram_corrupted = true;
                return {};
              }

              return std::string_view(line).substr(start + 1, end - start - 1);
            };

            // Parse OBIS numeric value from line, return NAN if not found or invalid
            auto parse_obis_value = [&](const std::string &line, const std::string &obis) -> float {
              std::string_view value_sv = parse_obis_string_value(line, obis, '*');
              if (value_sv.empty()) {
                return NAN;
              }

              float value = parse_float(value_sv);
              if (isnan(value)) {
                ESP_LOGW("meter", "Bad float %s: %s", trim_for_log(obis), trim_sv_for_log(value_sv));
                telegram_corrupted = true;
              }
              return value;
            };

            // Validate and update monotonic energy sensors (kWh)
            auto update_energy_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value, float min_range, float max_range) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                return;
              }
              
              // Validate: energy must be in valid range
              if (value < min_range) {
                ESP_LOGW("meter", "Reject %s: %.2f<%.1f", trim_for_log(obis), value, min_range);
                telegram_corrupted = true;
                return;
              }
              if (value > max_range) {
                ESP_LOGW("meter", "Reject %s: %.2f>%.1f", trim_for_log(obis), value, max_range);
                telegram_corrupted = true;
                return;
              }
              
              // Validate: energy must be evergrowing (or first reading)
              if (prev_value >= 0 && value < prev_value) {
                ESP_LOGW("meter", "Reject %s: %.2f<%.2f", trim_for_log(obis), value, prev_value);
                telegram_corrupted = true;
                return;
              }
              
              // Validate: energy change must be reasonable
              if (prev_value >= 0 && (value - prev_value) > MAX_ENERGY_CHANGE) {
                ESP_LOGW("meter", "Reject %s: Δ%.2f>%.0f", trim_for_log(obis), value - prev_value, MAX_ENERGY_CHANGE);
                telegram_corrupted = true;
                return;
              }
              
              sensor->publish_state(value);
              prev_value = value;
              ESP_LOGD("meter", "Updated %s: %.4f kWh", trim_for_log(obis), value);
            };

            // Validate and update rolling-window energy sensors (kWh)
            auto update_rolling_energy_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value, float min_range, float max_range) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                return;
              }

              // Validate: energy must be in valid range
              if (value < min_range) {
                ESP_LOGW("meter", "Reject %s: %.2f<%.1f", trim_for_log(obis), value, min_range);
                telegram_corrupted = true;
                return;
              }
              if (value > max_range) {
                ESP_LOGW("meter", "Reject %s: %.2f>%.1f", trim_for_log(obis), value, max_range);
                telegram_corrupted = true;
                return;
              }

              // Validate: change magnitude must be reasonable (allow increase OR decrease)
              if (prev_value >= 0 && fabs(value - prev_value) > MAX_ROLLING_ENERGY_CHANGE) {
                ESP_LOGW("meter", "Reject %s: |Δ|%.2f>%.0f", trim_for_log(obis), fabs(value - prev_value), MAX_ROLLING_ENERGY_CHANGE);
                telegram_corrupted = true;
                return;
              }

              sensor->publish_state(value);
              prev_value = value;
              ESP_LOGD("meter", "Updated (rolling) %s: %.4f kWh", trim_for_log(obis), value);
            };

            // Generic function to validate and update sensors with spike protection
            auto update_spike_protected_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value, 
                                                     float max_change, const char* unit, float min_range, float max_range) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                return;
              }
              
              // Validate: value must be in valid range
              if (value < min_range) {
                ESP_LOGW("meter", "Reject %s: %.1f<%.1f", trim_for_log(obis), value, min_range);
                telegram_corrupted = true;
                return;
              }
              if (value > max_range) {
                ESP_LOGW("meter", "Reject %s: %.1f>%.1f", trim_for_log(obis), value, max_range);
                telegram_corrupted = true;
                return;
              }
              
              // Validate: change must be reasonable (or first reading)
              if (prev_value >= 0 && fabs(value - prev_value) > max_change) {
                ESP_LOGW("meter", "Reject %s: Δ%.1f>%.0f%s", 
                         trim_for_log(obis), fabs(value - prev_value), max_change, unit);
                telegram_corrupted = true;
                return;
              }
              
              sensor->publish_state(value);
              prev_value = value;
              ESP_LOGD("meter", "Updated %s: %g %s", trim_for_log(obis), value, unit);
            };

            // Convenience wrappers for specific sensor types
            auto update_power_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value) {
              update_spike_protected_sensor(line, obis, sensor, prev_value, MAX_POWER_CHANGE, "W", MIN_POWER_VALUE, MAX_ABSOLUTE_POWER);
            };

            auto update_current_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value) {
              update_spike_protected_sensor(line, obis, sensor, prev_value, MAX_CURRENT_CHANGE, "A", MIN_CURRENT, MAX_CURRENT);
            };

            // Generic function to update numeric sensors with range validation
            auto update_numeric_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, const char* unit, float min_range, float max_range) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                return;
              }
              
              // Validate: value must be in valid range
              if (value < min_range) {
                ESP_LOGW("meter", "Reject %s: %.1f<%.1f", trim_for_log(obis), value, min_range);
                telegram_corrupted = true;
                return;
              }
              if (value > max_range) {
                ESP_LOGW("meter", "Reject %s: %.1f>%.1f", trim_for_log(obis), value, max_range);
                telegram_corrupted = true;
                return;
              }
              
              sensor->publish_state(value);
              ESP_LOGD("meter", "Updated %s: %.3f %s", trim_for_log(obis), value, unit);
            };

            // Parse and publish text sensor values with corruption filtering - hash-based for memory efficiency
            auto update_text_sensor_filtered = [&](const std::string &line, const std::string &obis, auto &sensor, uint32_t &last_hash, int &count) {
              std::string_view value_sv = parse_obis_string_value(line, obis, ')');
              if (value_sv.empty()) {
                return;
              }

              uint32_t current_hash = calculate_hash(value_sv);
              
              if (current_hash != last_hash) {
                last_hash = current_hash;
                count = 1;
                ESP_LOGD("meter", "New %s: %s (1/3)", trim_for_log(obis), trim_sv_for_log(value_sv));
                return;
              }
              
              if (count < 3) {
                count++;
              }
              
              if (count < 3) {
                ESP_LOGD("meter", "Buf %s: %s (%d/3)", trim_for_log(obis), trim_sv_for_log(value_sv), count);
                return;
              }
              
              // Only allocate string when we're ready to publish (3 consecutive identical values)
              std::string value_str(value_sv);
              sensor->publish_state(value_str);
              ESP_LOGD("meter", "Updated %s: %s (3x)", trim_for_log(obis), trim_for_log(value_str));
            };

            // Update energy sensors
            update_energy_sensor(x, "${obis_total_consumption}", id(total_consumption), id(prev_total_consumption), MIN_ENERGY_VALUE, MAX_ENERGY_TOTAL);
            update_rolling_energy_sensor(x, "${obis_consumption_1d}", id(consumption_1d), id(prev_consumption_1d), MIN_ENERGY_VALUE, MAX_CONSUMPTION_1D);
            update_rolling_energy_sensor(x, "${obis_consumption_7d}", id(consumption_7d), id(prev_consumption_7d), MIN_ENERGY_VALUE, MAX_CONSUMPTION_7D);
            update_rolling_energy_sensor(x, "${obis_consumption_30d}", id(consumption_30d), id(prev_consumption_30d), MIN_ENERGY_VALUE, MAX_CONSUMPTION_30D);
            update_rolling_energy_sensor(x, "${obis_consumption_365d}", id(consumption_365d), id(prev_consumption_365d), MIN_ENERGY_VALUE, MAX_CONSUMPTION_365D);
            update_energy_sensor(x, "${obis_consumption_t1}", id(consumption_t1), id(prev_consumption_t1), MIN_ENERGY_VALUE, MAX_ENERGY_TOTAL);
            update_energy_sensor(x, "${obis_consumption_t2}", id(consumption_t2), id(prev_consumption_t2), MIN_ENERGY_VALUE, MAX_ENERGY_TOTAL);
            update_energy_sensor(x, "${obis_consumption_since_reset}", id(consumption_since_reset), id(prev_consumption_since_reset), MIN_ENERGY_VALUE, MAX_ENERGY_TOTAL);

            // Update power sensor
            update_power_sensor(x, "${obis_current_power}", id(current_power), id(prev_current_power));

            // Update voltage sensors
            update_numeric_sensor(x, "${obis_voltage_l1}", id(voltage_l1), "V", MIN_VOLTAGE, MAX_VOLTAGE);
            update_numeric_sensor(x, "${obis_voltage_l2}", id(voltage_l2), "V", MIN_VOLTAGE, MAX_VOLTAGE);
            update_numeric_sensor(x, "${obis_voltage_l3}", id(voltage_l3), "V", MIN_VOLTAGE, MAX_VOLTAGE);

            // Update current sensors with spike protection
            update_current_sensor(x, "${obis_current_l1}", id(current_l1), id(prev_current_l1));
            update_current_sensor(x, "${obis_current_l2}", id(current_l2), id(prev_current_l2));
            update_current_sensor(x, "${obis_current_l3}", id(current_l3), id(prev_current_l3));

            // Update frequency sensor
            update_numeric_sensor(x, "${obis_frequency}", id(frequency), "Hz", MIN_FREQUENCY, MAX_FREQUENCY);

            // Update phase angle sensors
            update_numeric_sensor(x, "${obis_phase_angle_ul2_ul1}", id(phase_angle_ul2_ul1), "deg", MIN_PHASE_ANGLE, MAX_PHASE_ANGLE);
            update_numeric_sensor(x, "${obis_phase_angle_ul3_ul1}", id(phase_angle_ul3_ul1), "deg", MIN_PHASE_ANGLE, MAX_PHASE_ANGLE);
            update_numeric_sensor(x, "${obis_phase_angle_il1_ul1}", id(phase_angle_il1_ul1), "deg", MIN_PHASE_ANGLE, MAX_PHASE_ANGLE);
            update_numeric_sensor(x, "${obis_phase_angle_il2_ul2}", id(phase_angle_il2_ul2), "deg", MIN_PHASE_ANGLE, MAX_PHASE_ANGLE);
            update_numeric_sensor(x, "${obis_phase_angle_il3_ul3}", id(phase_angle_il3_ul3), "deg", MIN_PHASE_ANGLE, MAX_PHASE_ANGLE);

            // Update text sensors with corruption filtering - using hash-based comparison
            update_text_sensor_filtered(x, "${obis_serial_number}", id(serial_number), id(serial_number_last_hash), id(serial_number_count));
            update_text_sensor_filtered(x, "${obis_firmware_version}", id(firmware_version), id(firmware_version_last_hash), id(firmware_version_count));
            update_text_sensor_filtered(x, "${obis_parameter_crc}", id(parameter_crc), id(parameter_crc_last_hash), id(parameter_crc_count));
            update_text_sensor_filtered(x, "${obis_status_register}", id(status_register), id(status_register_last_hash), id(status_register_count));

            // Count corrupted telegrams
            if (telegram_corrupted) {
              id(corruption_count)++;
            }

  # Meter information text sensors
  - platform: deduplicate_text
    name: "Serial Number"
    id: serial_number
    icon: "mdi:identifier"
    entity_category: diagnostic
  - platform: deduplicate_text
    name: "Firmware Version"
    id: firmware_version
    icon: "mdi:information-outline"
    entity_category: diagnostic
  - platform: deduplicate_text
    name: "Parameter CRC"
    id: parameter_crc
    icon: "mdi:checksum"
    entity_category: diagnostic
  - platform: deduplicate_text
    name: "Status Register"
    id: status_register
    icon: "mdi:alert-circle-outline"
    entity_category: diagnostic

# Energy and power sensors
sensor:
  - platform: template
    name: "Total Consumption"
    id: total_consumption
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption 1 Day"
    id: consumption_1d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption 7 Days"
    id: consumption_7d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption 30 Days"
    id: consumption_30d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption 365 Days"
    id: consumption_365d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption T1"
    id: consumption_t1
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption T2"
    id: consumption_t2
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Consumption Since Reset"
    id: consumption_since_reset
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - or:
          - throttle: 5min
          - delta: 0.001
  - platform: template
    name: "Current Power"
    id: current_power
    unit_of_measurement: W
    accuracy_decimals: 0
    device_class: power
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1
  # Voltage sensors
  - platform: template
    name: "Voltage L1"
    id: voltage_l1
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  - platform: template
    name: "Voltage L2"
    id: voltage_l2
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  - platform: template
    name: "Voltage L3"
    id: voltage_l3
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Current sensors
  - platform: template
    name: "Current L1"
    id: current_l1
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.01
  - platform: template
    name: "Current L2"
    id: current_l2
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.01
  - platform: template
    name: "Current L3"
    id: current_l3
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.01
  # Frequency sensor
  - platform: template
    name: "Frequency"
    id: frequency
    unit_of_measurement: Hz
    accuracy_decimals: 1
    device_class: frequency
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Phase angle sensors
  - platform: template
    name: "Phase Angle UL2:UL1"
    id: phase_angle_ul2_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle UL3:UL1"
    id: phase_angle_ul3_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL1:UL1"
    id: phase_angle_il1_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL2:UL2"
    id: phase_angle_il2_ul2
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL3:UL3"
    id: phase_angle_il3_ul3
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - or:
          - throttle: 5min
          - delta: 1.0
  # Communication quality sensor
  - platform: template
    name: "OBIS Valid Frame Rate"
    id: obis_valid_frame_rate
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    disabled_by_default: true
    update_interval: 30s
    lambda: |-
      // Atomic snapshots to prevent race conditions
      uint32_t total_telegrams = id(total_frames_received);
      uint32_t corruption_events = id(corruption_count);
      
      // Prevent race condition by re-reading if corruption > total
      if (corruption_events > total_telegrams) {
        total_telegrams = id(total_frames_received);
        corruption_events = id(corruption_count);
        // If still inconsistent, use previous total
        if (corruption_events > total_telegrams) {
          corruption_events = total_telegrams;
        }
      }

      // Overflow protection
      if (total_telegrams >= 4000000u || corruption_events >= 4000000u) {
        uint32_t new_total = total_telegrams / 2;
        uint32_t new_corruption = corruption_events / 2;
        
        ESP_LOGW("meter", "Overflow: %u/%u->%u/%u", 
                   total_telegrams, corruption_events, new_total, new_corruption);
        
        id(total_frames_received) = new_total;
        id(corruption_count) = new_corruption;
        total_telegrams = new_total;
        corruption_events = new_corruption;
      }

      if (total_telegrams == 0) return 0.0;
      
      // Use uint32_t to prevent underflow, then cast to float
      uint32_t successfully_processed = total_telegrams - corruption_events;
      
      return (float(successfully_processed) / float(total_telegrams)) * 100.0;
    filters:
      - or:
          - throttle: 2min
          - delta: 0.1

# Reset buttons
button:
  - platform: template
    name: "Reset Validation State"
    id: reset_validation_state
    icon: "mdi:backup-restore"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(prev_total_consumption) = -1.0;
          id(prev_consumption_1d) = -1.0;
          id(prev_consumption_7d) = -1.0;
          id(prev_consumption_30d) = -1.0;
          id(prev_consumption_365d) = -1.0;
          id(prev_current_power) = -1.0;
          id(prev_consumption_t1) = -1.0;
          id(prev_consumption_t2) = -1.0;
          id(prev_consumption_since_reset) = -1.0;
          id(prev_current_l1) = -1.0;
          id(prev_current_l2) = -1.0;
          id(prev_current_l3) = -1.0;
          id(serial_number_last_hash) = 0;
          id(serial_number_count) = 0;
          id(firmware_version_last_hash) = 0;
          id(firmware_version_count) = 0;
          id(parameter_crc_last_hash) = 0;
          id(parameter_crc_count) = 0;
          id(status_register_last_hash) = 0;
          id(status_register_count) = 0;
          ESP_LOGI("meter", "Validation state reset");
  - platform: template
    name: "Reset Communication Quality"
    id: reset_communication_quality
    icon: "mdi:refresh"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(total_frames_received) = 0;
          id(corruption_count) = 0;
          ESP_LOGI("meter", "Quality counters reset"); 
  - platform: restart
    name: "Restart Device"
    id: restart_device
    icon: "mdi:restart"
    entity_category: diagnostic 