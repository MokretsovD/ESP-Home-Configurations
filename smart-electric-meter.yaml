---
substitutions:
  name: smart-electric-meter
  friendly_name: Smart Electric Meter
  device_static_ip: !secret smart_electric_meter_wifi_manual_ip_static_ip
  device_ap_ssid: !secret smart_electric_meter_wifi_ap_ssid
  device_ap_password: !secret smart_electric_meter_wifi_ap_password
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  wifi_manual_ip_gateway: !secret wifi_manual_ip_gateway
  wifi_manual_ip_subnet: !secret wifi_manual_ip_subnet
  mqtt_broker: !secret mqtt_broker
  mqtt_username: !secret mqtt_username
  mqtt_password: !secret mqtt_password
  mqtt_topic_prefix: tele/tasmota_3D87A3

  # Validation constants for meter readings
  max_realistic_power: "17250.0" # 17.25kW (25A * 3 phases * 230V)
  max_absolute_power: "34500.0" # 34.5kW (2x realistic power as absolute limit)
  max_power_change: "3000.0" # 3kW max power change per reading
  max_current_change: "13.0" # 13A max current change per reading (derived from 3kW/230V)
  max_energy_total: "100000.0" # 100,000 kWh reasonable lifetime maximum
  max_energy_change: "1.0" # 1 kWh max energy change per reading
  min_energy_value: "0.0" # Minimum energy value (kWh)
  min_power_value: "0.0" # Minimum power value (W)

  # OBIS codes for smart meter readings
  obis_total_consumption: "1-0:1.8.0*255" # Total energy consumption (kWh)
  obis_consumption_1d: "1-0:1.8.0*96" # Energy consumption last 1 day (kWh)
  obis_consumption_7d: "1-0:1.8.0*97" # Energy consumption last 7 days (kWh)
  obis_consumption_30d: "1-0:1.8.0*98" # Energy consumption last 30 days (kWh)
  obis_consumption_365d: "1-0:1.8.0*99" # Energy consumption last 365 days (kWh)
  # obis_total_feed_in: "1-0:2.8.0*255" # Total energy feed-in (kWh)
  obis_current_power: "1-0:16.7.0*255" # Current power consumption (W)

  # Additional OBIS codes for comprehensive meter reading
  obis_serial_number: "1-0:96.1.0*255" # Serial number/identification
  obis_consumption_t1: "1-0:1.8.1*255" # Energy consumption T1 (kWh)
  obis_consumption_t2: "1-0:1.8.2*255" # Energy consumption T2 (kWh)
  obis_voltage_l1: "1-0:32.7.0*255" # Voltage L1 (V)
  obis_voltage_l2: "1-0:52.7.0*255" # Voltage L2 (V)
  obis_voltage_l3: "1-0:72.7.0*255" # Voltage L3 (V)
  obis_current_l1: "1-0:31.7.0*255" # Current L1 (A)
  obis_current_l2: "1-0:51.7.0*255" # Current L2 (A)
  obis_current_l3: "1-0:71.7.0*255" # Current L3 (A)
  obis_phase_angle_ul2_ul1: "1-0:81.7.1*255" # Phase angle UL2:UL1 (deg)
  obis_phase_angle_ul3_ul1: "1-0:81.7.2*255" # Phase angle UL3:UL1 (deg)
  obis_phase_angle_il1_ul1: "1-0:81.7.4*255" # Phase angle IL1:UL1 (deg)
  obis_phase_angle_il2_ul2: "1-0:81.7.15*255" # Phase angle IL2:UL2 (deg)
  obis_phase_angle_il3_ul3: "1-0:81.7.26*255" # Phase angle IL3:UL3 (deg)
  obis_frequency: "1-0:14.7.0*255" # Network frequency (Hz)
  obis_consumption_since_reset: "1-0:1.8.0*100" # Energy since last reset (kWh)
  obis_firmware_version: "1-0:0.2.0*255" # Firmware version info
  obis_parameter_crc: "1-0:96.90.2*255" # Parameter CRC checksum
  obis_status_register: "1-0:97.97.0*255" # Status register

  # Additional validation constants
  max_voltage: "280.0" # 280V (max reasonable voltage)
  min_voltage: "0.0" # 0V (min voltage)
  max_current: "30.0" # 30A (max reasonable current)
  min_current: "0.0" # 0A (min current)
  max_frequency: "52.0" # 55Hz (max frequency)
  min_frequency: "48.0" # 45Hz (min frequency)
  max_phase_angle: "360.0" # 360° (max phase angle)
  min_phase_angle: "-360.0" # -360° (min phase angle)

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2024.6.0

external_components:
  - source:
      type: local
      path: components

esp8266:
  board: d1_mini

preferences:
  flash_write_interval: 5min

# Enable debug logging
logger:
  level: DEBUG

# Enable OTA updates
ota:
  - platform: esphome
    password: !secret smart_electric_meter_esp_ota_password

# WiFi and signal sensors via packages
packages:
  wifi: !include packages/wifi.yaml
  wifi-signal-sensors: !include packages/wifi-signal-sensors.yaml
  wifi-diagnostic-sensors: !include packages/wifi-diagnostic-sensors.yaml
  factory-reset-button: !include packages/factory-reset-button.yaml

captive_portal:

# MQTT (no API)
mqtt:
  broker: ${mqtt_broker}
  username: ${mqtt_username}
  password: ${mqtt_password}
  topic_prefix: ${mqtt_topic_prefix}
  birth_message:
    topic: ${mqtt_topic_prefix}/LWT
    payload: Online
  will_message:
    topic: ${mqtt_topic_prefix}/LWT
    payload: Offline
  discovery: true
  id: mqttclient
  on_connect:
    - lambda: |-
        id(mqtt_connect_counter)++;
        ESP_LOGI("mqtt", "MQTT connected, count: %d", id(mqtt_connect_counter));

# web_server:

# Global variables for validation state tracking
globals:
  - id: prev_total_consumption
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_1d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_7d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_30d
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_365d
    type: float
    initial_value: "-1.0"
  # - id: prev_total_feed_in
  #  type: float
  #  initial_value: "-1.0"
  - id: prev_current_power
    type: float
    initial_value: "-1.0"
  # Additional global variables for additional OBIS codes (only for sensors that need validation)
  - id: prev_consumption_t1
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_t2
    type: float
    initial_value: "-1.0"
  - id: prev_consumption_since_reset
    type: float
    initial_value: "-1.0"
  # Global variables for current spike protection
  - id: prev_current_l1
    type: float
    initial_value: "-1.0"
  - id: prev_current_l2
    type: float
    initial_value: "-1.0"
  - id: prev_current_l3
    type: float
    initial_value: "-1.0"

  # Global variables for communication quality tracking
  - id: total_frames_received
    type: int
    initial_value: "0"
  - id: corruption_count
    type: int
    initial_value: "0"

  # Global variable for MQTT connect count
  - id: mqtt_connect_counter
    type: int
    initial_value: "0"

  # Global variables for text sensor corruption filtering (3 times in a row)
  - id: serial_number_last
    type: std::string
    initial_value: '""'
  - id: serial_number_count
    type: int
    initial_value: "0"
  - id: firmware_version_last
    type: std::string
    initial_value: '""'
  - id: firmware_version_count
    type: int
    initial_value: "0"
  - id: parameter_crc_last
    type: std::string
    initial_value: '""'
  - id: parameter_crc_count
    type: int
    initial_value: "0"
  - id: status_register_last
    type: std::string
    initial_value: '""'
  - id: status_register_count
    type: int
    initial_value: "0"

# UART for IR head
uart:
  rx_pin: D2 #D7
  baud_rate: 9600 # 2400, 1200, 4800, 9600
  id: uart_bus
  #  parity: NONE     # Common for smart meters
  #  data_bits: 8     # Common for smart meters
  parity: EVEN # Common for smart meters
  data_bits: 7 # Common for smart meters
  stop_bits: 1
  rx_buffer_size: 1024
  # Enable UART debug output
  # debug:
  #   direction: RX
  #   dummy_receiver: false
  #   after:
  #     delimiter: "\n"
  #   sequence:
  #     - lambda: UARTDebug::log_string(direction, bytes);

# --- Custom UART/text sensor approach for ASCII OBIS output ---
text_sensor:
  - platform: uart_line_reader
    uart_id: uart_bus
    name: "OBIS Raw Line"
    id: obis_raw_line
    internal: true
    filters:
      - lambda: |-
          if (x.length() < 10) return {};
          if (x[0] != '0' && x[0] != '1') return {};
          if (x.find('*') == std::string::npos ||
              x.find('(') == std::string::npos ||
              x.find(')') == std::string::npos) return {};

          return x;
    on_value:
      then:
        - lambda: |-
            // Track OBIS telegram processing for quality metrics
            id(total_frames_received)++;

            // Flag to track if corruption occurred in this telegram
            bool telegram_corrupted = false;

            // Using ESPHome globals for validation state tracking

            // Validation constants from substitutions (absolute limits now handled by clamp filters)
            const float MAX_POWER_CHANGE = ${max_power_change}; // 3kW max power change per reading
            const float MAX_CURRENT_CHANGE = ${max_current_change}; // 13A max current change per reading
            const float MAX_ENERGY_CHANGE = ${max_energy_change}; // 100 kWh max energy change per reading

            // Use ESPHome's built-in parse_number function
            auto parse_float = [](const std::string &str) -> float {
              auto n = parse_number<float>(str);
              return n.has_value() ? n.value() : NAN;
            };

            // Parse OBIS string value from line, return empty string if not found or invalid
            // Sets telegram_corrupted flag if OBIS code is found but malformed
            auto parse_obis_string_value = [&](const std::string &line, const std::string &obis, char delimiter) -> std::string {
              size_t pos = line.find(obis);
              if (pos == std::string::npos) {
                // OBIS code not found - this is normal, not corruption
                return "";
              }
              
              size_t start = line.find('(', pos);
              if (start == std::string::npos) {
                ESP_LOGW("meter", "Opening parenthesis not found for %s in line: %s", obis.c_str(), line.c_str());
                telegram_corrupted = true; // Found OBIS code but malformed
                return "";
              }
              
              size_t end = line.find(delimiter, start);
              if (end == std::string::npos || end <= start) {
                ESP_LOGW("meter", "Delimiter '%c' not found or invalid for %s in line: %s", delimiter, obis.c_str(), line.c_str());
                telegram_corrupted = true; // Found OBIS code but malformed
                return "";
              }
              
              return line.substr(start+1, end-start-1);
            };

            // Parse OBIS numeric value from line, return NAN if not found or invalid
            // Sets telegram_corrupted flag if OBIS code is found but malformed
            auto parse_obis_value = [&](const std::string &line, const std::string &obis) -> float {
              std::string value_str = parse_obis_string_value(line, obis, '*');
              if (value_str.empty()) {
                return NAN;
              }
              
              float value = parse_float(value_str);
              if (isnan(value)) {
                ESP_LOGW("meter", "Invalid float format for %s: '%s'", obis.c_str(), value_str.c_str());
                telegram_corrupted = true; // Found OBIS code but invalid value
              }
              return value;
            };

            // Validate and update energy sensors (kWh) - clamp filters handle min/max bounds
            auto update_energy_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                // OBIS code not found or already marked as corrupted in parse_obis_value
                return;
              }
              
              // Validate: energy must be evergrowing (or first reading)
              if (prev_value >= 0 && value < prev_value) {
                ESP_LOGW("meter", "Rejected %s: %.4f kWh (less than previous %.4f kWh)", obis.c_str(), value, prev_value);
                telegram_corrupted = true; // Invalid energy value - corrupted telegram
                return;
              }
              
              // Validate: energy change must be reasonable
              if (prev_value >= 0 && (value - prev_value) > MAX_ENERGY_CHANGE) {
                ESP_LOGW("meter", "Rejected %s: %.4f kWh (change %.4f kWh > limit %.0f kWh)", obis.c_str(), value, value - prev_value, MAX_ENERGY_CHANGE);
                telegram_corrupted = true; // Unreasonable energy change - corrupted telegram
                return;
              }
              
              // All validations passed - clamp filter will handle min/max bounds
              sensor->publish_state(value);
              prev_value = value;
              ESP_LOGD("meter", "Updated %s: %.4f kWh", obis.c_str(), value);
            };

            // Generic function to validate and update sensors with spike protection
            auto update_spike_protected_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value, 
                                                     float max_change, const char* unit) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                // OBIS code not found or already marked as corrupted in parse_obis_value
                return;
              }
              
              // Validate: change must be reasonable (or first reading)
              if (prev_value >= 0 && abs(value - prev_value) > max_change) {
                ESP_LOGW("meter", "Rejected %s: %g %s (change %g %s > limit %g %s)", 
                         obis.c_str(), value, unit, abs(value - prev_value), unit, max_change, unit);
                telegram_corrupted = true; // Unreasonable change - corrupted telegram
                return;
              }
              
              // All validations passed - clamp filter will handle min/max bounds
              sensor->publish_state(value);
              prev_value = value;
              ESP_LOGD("meter", "Updated %s: %g %s", obis.c_str(), value, unit);
            };

            // Convenience wrappers for specific sensor types
            auto update_power_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value) {
              update_spike_protected_sensor(line, obis, sensor, prev_value, MAX_POWER_CHANGE, "W");
            };

            auto update_current_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, float &prev_value) {
              update_spike_protected_sensor(line, obis, sensor, prev_value, MAX_CURRENT_CHANGE, "A");
            };

            // Update energy sensors (kWh) with comprehensive validation
            update_energy_sensor(x, "${obis_total_consumption}", id(total_consumption), id(prev_total_consumption));
            update_energy_sensor(x, "${obis_consumption_1d}", id(consumption_1d), id(prev_consumption_1d));
            update_energy_sensor(x, "${obis_consumption_7d}", id(consumption_7d), id(prev_consumption_7d));
            update_energy_sensor(x, "${obis_consumption_30d}", id(consumption_30d), id(prev_consumption_30d));
            update_energy_sensor(x, "${obis_consumption_365d}", id(consumption_365d), id(prev_consumption_365d));
            // update_energy_sensor(x, "{obis_total_feed_in}", id(total_feed_in), id(prev_total_feed_in));

            // Update power sensor (W) with spike protection
            update_power_sensor(x, "${obis_current_power}", id(current_power), id(prev_current_power));

            // Update additional energy sensors
            update_energy_sensor(x, "${obis_consumption_t1}", id(consumption_t1), id(prev_consumption_t1));
            update_energy_sensor(x, "${obis_consumption_t2}", id(consumption_t2), id(prev_consumption_t2));
            update_energy_sensor(x, "${obis_consumption_since_reset}", id(consumption_since_reset), id(prev_consumption_since_reset));

            // Generic function to update numeric sensors (no validation needed - clamp filters handle bounds)
            auto update_numeric_sensor = [&](const std::string &line, const std::string &obis, auto &sensor, const char* unit) {
              float value = parse_obis_value(line, obis);
              if (isnan(value)) {
                // OBIS code not found or already marked as corrupted in parse_obis_value
                return;
              }
              
              // Update sensor (clamp filter will handle bounds)
              sensor->publish_state(value);
              ESP_LOGD("meter", "Updated %s: %.3f %s", obis.c_str(), value, unit);
            };

            // Parse and publish text sensor values with corruption filtering (3 times in a row)
            auto update_text_sensor_filtered = [&](const std::string &line, const std::string &obis, auto &sensor, std::string &last_value, int &count) {
              std::string value_str = parse_obis_string_value(line, obis, ')');
              if (value_str.empty()) {
                // OBIS code not found or parsing failed (corruption already handled in parse_obis_string_value)
                return;
              }
              
              // Handle new value - reset counter and return early
              if (value_str != last_value) {
                last_value = value_str;
                count = 1;
                ESP_LOGD("meter", "New value %s: %s (count: 1, need 2 more)", obis.c_str(), value_str.c_str());
                return;
              }
              
              // Same value - increment counter if not already at 3
              if (count < 3) {
                count++;
              }
              
              // Still need more confirmations - return early
              if (count < 3) {
                ESP_LOGD("meter", "Buffering %s: %s (count: %d, need %d more)", obis.c_str(), value_str.c_str(), count, 3 - count);
                return;
              }
              
              // Got 3 confirmations - publish value
              sensor->publish_state(value_str);
              ESP_LOGD("meter", "Updated %s: %s (confirmed 3x)", obis.c_str(), value_str.c_str());
            };

            // Update voltage sensors
            update_numeric_sensor(x, "${obis_voltage_l1}", id(voltage_l1), "V");
            update_numeric_sensor(x, "${obis_voltage_l2}", id(voltage_l2), "V");
            update_numeric_sensor(x, "${obis_voltage_l3}", id(voltage_l3), "V");

            // Update current sensors with spike protection
            update_current_sensor(x, "${obis_current_l1}", id(current_l1), id(prev_current_l1));
            update_current_sensor(x, "${obis_current_l2}", id(current_l2), id(prev_current_l2));
            update_current_sensor(x, "${obis_current_l3}", id(current_l3), id(prev_current_l3));

            // Update frequency sensor
            update_numeric_sensor(x, "${obis_frequency}", id(frequency), "Hz");

            // Update phase angle sensors
            update_numeric_sensor(x, "${obis_phase_angle_ul2_ul1}", id(phase_angle_ul2_ul1), "deg");
            update_numeric_sensor(x, "${obis_phase_angle_ul3_ul1}", id(phase_angle_ul3_ul1), "deg");
            update_numeric_sensor(x, "${obis_phase_angle_il1_ul1}", id(phase_angle_il1_ul1), "deg");
            update_numeric_sensor(x, "${obis_phase_angle_il2_ul2}", id(phase_angle_il2_ul2), "deg");
            update_numeric_sensor(x, "${obis_phase_angle_il3_ul3}", id(phase_angle_il3_ul3), "deg");

            // Update text sensors with corruption filtering
            update_text_sensor_filtered(x, "${obis_serial_number}", id(serial_number), id(serial_number_last), id(serial_number_count));
            update_text_sensor_filtered(x, "${obis_firmware_version}", id(firmware_version), id(firmware_version_last), id(firmware_version_count));
            update_text_sensor_filtered(x, "${obis_parameter_crc}", id(parameter_crc), id(parameter_crc_last), id(parameter_crc_count));
            update_text_sensor_filtered(x, "${obis_status_register}", id(status_register), id(status_register_last), id(status_register_count));

            // Count corrupted telegrams (only once per telegram)
            if (telegram_corrupted) {
              id(corruption_count)++;
            }

  # Additional text sensors for meter information (corruption filtering handled in OBIS parsing)
  - platform: template
    name: "Serial Number"
    id: serial_number
    icon: "mdi:identifier"
    entity_category: diagnostic
    filters:
      - lambda: |-
          static std::string last_serial;
          if (x == last_serial)
            return {};
          last_serial = x;
          return x;
  - platform: template
    name: "Firmware Version"
    id: firmware_version
    icon: "mdi:information-outline"
    entity_category: diagnostic
    filters:
      - lambda: |-
          static std::string last_firmware;
          if (x == last_firmware)
            return {};
          last_firmware = x;
          return x;
  - platform: template
    name: "Parameter CRC"
    id: parameter_crc
    icon: "mdi:checksum"
    entity_category: diagnostic
    filters:
      - lambda: |-
          static std::string last_crc;
          if (x == last_crc)
            return {};
          last_crc = x;
          return x;
  - platform: template
    name: "Status Register"
    id: status_register
    icon: "mdi:alert-circle-outline"
    entity_category: diagnostic
    filters:
      - lambda: |-
          static std::string last_status;
          if (x == last_status)
            return {};
          last_status = x;
          return x;

# -----------------------------------------------------------------------------
# Handshake logic: keep the meter in printable IEC-62056-21 ASCII mode
# -----------------------------------------------------------------------------

# Never tested this, not sure this actually works, but added it here for reference for counters that
# require handshake before sending any data.

# script:
#   - id: meter_handshake
#     mode: queued
#     then:
#       # Give the UART some time after boot / Wi-Fi reconnects
#       - delay: 3s
#       # 1) "/?!\r\n" – enquiry according to IEC-62056-21
#       - uart.write: "/?!\r\n"
#       # 2) Wait for the meter to answer with the identification string
#       - delay: 300ms
#       # 3) ACK + mode/baud selector (0 6 0 => mode C, 9600 Bd, normal wait-time)
#       - lambda: |-
#           constexpr uint8_t ack[] = {0x06, '0', '6', '0', '\r', '\n'};
#           id(uart_bus).write_array(ack, sizeof(ack));

# # Execute once after every reboot and repeat regularly (meter falls back to
# # idle mode after a few minutes without traffic).

# on_boot:
#   priority: -10
#   then:
#     - script.execute: meter_handshake

# interval:
#   - interval: 15min
#     then:
#       - script.execute: meter_handshake

sensor:
  - platform: template
    name: "Total Consumption"
    id: total_consumption
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption 1 Day"
    id: consumption_1d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption 7 Days"
    id: consumption_7d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption 30 Days"
    id: consumption_30d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption 365 Days"
    id: consumption_365d
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Current Power"
    id: current_power
    unit_of_measurement: W
    accuracy_decimals: 0
    device_class: power
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_power_value}
          max_value: ${max_absolute_power}
      - or:
          - throttle: 5min
          - delta: 1
  # - platform: template
  #   name: "Total Feed-in"
  #   id: total_feed_in
  #   unit_of_measurement: kWh
  #   accuracy_decimals: 4
  #   device_class: energy
  #   state_class: total_increasing
  #   filters:
  #     - clamp:
  #         min_value: ${min_energy_value}
  #         max_value: ${max_energy_total}
  #     - or:
  #         - throttle: 5min
  #         - delta: 0.0001
  # Nice to have: uptime sensor
  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: 60s
    entity_category: diagnostic
    disabled_by_default: true

  # Additional energy sensors
  - platform: template
    name: "Consumption T1"
    id: consumption_t1
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption T2"
    id: consumption_t2
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  - platform: template
    name: "Consumption Since Reset"
    id: consumption_since_reset
    unit_of_measurement: kWh
    accuracy_decimals: 4
    device_class: energy
    state_class: total_increasing
    filters:
      - clamp:
          min_value: ${min_energy_value}
          max_value: ${max_energy_total}
      - or:
          - throttle: 5min
          - delta: 0.0001
  # Voltage sensors
  - platform: template
    name: "Voltage L1"
    id: voltage_l1
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_voltage}
          max_value: ${max_voltage}
      - or:
          - throttle: 5min
          - delta: 0.1
  - platform: template
    name: "Voltage L2"
    id: voltage_l2
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_voltage}
          max_value: ${max_voltage}
      - or:
          - throttle: 5min
          - delta: 0.1
  - platform: template
    name: "Voltage L3"
    id: voltage_l3
    unit_of_measurement: V
    accuracy_decimals: 1
    device_class: voltage
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_voltage}
          max_value: ${max_voltage}
      - or:
          - throttle: 5min
          - delta: 0.1

  # Current sensors
  - platform: template
    name: "Current L1"
    id: current_l1
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_current}
          max_value: ${max_current}
      - or:
          - throttle: 5min
          - delta: 0.01
  - platform: template
    name: "Current L2"
    id: current_l2
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_current}
          max_value: ${max_current}
      - or:
          - throttle: 5min
          - delta: 0.01
  - platform: template
    name: "Current L3"
    id: current_l3
    unit_of_measurement: A
    accuracy_decimals: 2
    device_class: current
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_current}
          max_value: ${max_current}
      - or:
          - throttle: 5min
          - delta: 0.01

  # Frequency sensor
  - platform: template
    name: "Frequency"
    id: frequency
    unit_of_measurement: Hz
    accuracy_decimals: 1
    device_class: frequency
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_frequency}
          max_value: ${max_frequency}
      - or:
          - throttle: 5min
          - delta: 0.1

  # Phase angle sensors
  - platform: template
    name: "Phase Angle UL2:UL1"
    id: phase_angle_ul2_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_phase_angle}
          max_value: ${max_phase_angle}
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle UL3:UL1"
    id: phase_angle_ul3_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_phase_angle}
          max_value: ${max_phase_angle}
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL1:UL1"
    id: phase_angle_il1_ul1
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_phase_angle}
          max_value: ${max_phase_angle}
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL2:UL2"
    id: phase_angle_il2_ul2
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_phase_angle}
          max_value: ${max_phase_angle}
      - or:
          - throttle: 5min
          - delta: 1.0
  - platform: template
    name: "Phase Angle IL3:UL3"
    id: phase_angle_il3_ul3
    unit_of_measurement: "°"
    accuracy_decimals: 0
    icon: "mdi:angle-acute"
    state_class: measurement
    filters:
      - clamp:
          min_value: ${min_phase_angle}
          max_value: ${max_phase_angle}
      - or:
          - throttle: 5min
          - delta: 1.0

  # Communication quality sensors
  - platform: template
    name: "OBIS Valid Frame Rate"
    id: obis_valid_frame_rate
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    disabled_by_default: true
    update_interval: 1s
    lambda: |-
      int total_telegrams = id(total_frames_received);
      int corruption_events = id(corruption_count);

      // Overflow protection for both counters - reduce proportionally to maintain ratio
      if (total_telegrams >= 10000 || corruption_events >= 10000) {
        int new_total = total_telegrams / 2;
        int new_corruption = corruption_events / 2;
        ESP_LOGI("meter", "Counter overflow protection triggered - reducing counters from %d/%d to %d/%d", 
                 total_telegrams, corruption_events, new_total, new_corruption);
        id(total_frames_received) = new_total;
        id(corruption_count) = new_corruption;
        // Recalculate with new values
        total_telegrams = new_total;
        corruption_events = new_corruption;
      }

      if (total_telegrams == 0) return 0.0;
      int successfully_processed = total_telegrams - corruption_events;
      if (successfully_processed < 0) successfully_processed = 0;

      return (float(successfully_processed) / float(total_telegrams)) * 100.0;
    filters:
      - or:
          - throttle: 2min
          - delta: 0.1

  # MQTT connect count sensor
  - platform: template
    name: "MQTT Connect Count"
    id: mqtt_connect_count
    unit_of_measurement: ""
    accuracy_decimals: 0
    entity_category: "diagnostic"
    disabled_by_default: true
    icon: "mdi:mqtt"
    state_class: "total"
    lambda: return id(mqtt_connect_counter);

button:
  # Reset validation state - using button instead of switch
  - platform: template
    name: "Reset Validation State"
    id: reset_validation_state
    icon: "mdi:backup-restore"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(prev_total_consumption) = -1.0;
          id(prev_consumption_1d) = -1.0;
          id(prev_consumption_7d) = -1.0;
          id(prev_consumption_30d) = -1.0;
          id(prev_consumption_365d) = -1.0;
          // id(prev_total_feed_in) = -1.0;
          id(prev_current_power) = -1.0;
          // Reset additional energy sensors (only ones that need validation)
          id(prev_consumption_t1) = -1.0;
          id(prev_consumption_t2) = -1.0;
          id(prev_consumption_since_reset) = -1.0;
          // Reset current sensor previous values
          id(prev_current_l1) = -1.0;
          id(prev_current_l2) = -1.0;
          id(prev_current_l3) = -1.0;
          // Reset text sensor filtering state
          id(serial_number_last) = "";
          id(serial_number_count) = 0;
          id(firmware_version_last) = "";
          id(firmware_version_count) = 0;
          id(parameter_crc_last) = "";
          id(parameter_crc_count) = 0;
          id(status_register_last) = "";
          id(status_register_count) = 0;
          
          ESP_LOGI("meter", "Validation state counters and text sensor filtering reset");

  # Reset communication quality counters only
  - platform: template
    name: "Reset Communication Quality"
    id: reset_communication_quality
    icon: "mdi:refresh"
    entity_category: diagnostic
    disabled_by_default: true
    on_press:
      - lambda: |-
          id(total_frames_received) = 0;
          id(corruption_count) = 0;
          // Reset connection counters
          id(mqtt_connect_counter) = 0;
          id(wifi_connect_counter) = 0;
          ESP_LOGI("meter", "Communication quality and connection counters reset");


# Optionally, add a status LED (uncomment and set pin if desired)
# output:
#   - platform: gpio
#     pin: D4
#     id: status_led
# status_led:
#   pin:
#     number: D4
#     inverted: true
