---
substitutions:
  device_static_ip: !secret lilygos3_info_screen_wifi_manual_ip_static_ip
  device_ap_ssid: !secret lilygos3_info_screen_wifi_ap_ssid
  device_ap_password: !secret lilygos3_info_screen_wifi_ap_password
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  wifi_manual_ip_gateway: !secret wifi_manual_ip_gateway
  wifi_manual_ip_subnet: !secret wifi_manual_ip_subnet

esphome:
  name: lilygos3-info-screen
  friendly_name: lilygos3-info-screen
  platformio_options:
    board_build.f_flash: 80000000L
    board_build.partitions: default_16MB.csv
    board_build.arduino.memory_type: qio_opi
  on_boot:
    # priority has been determined by trial and error
    # it should be lower than gpio components and higher than interval components
    - priority: 300
    # publish required states on boot
      then:
        - lambda: |-
                  id(in_deep_sleep).publish_state(false);                  
                  id(wakeup_cause).publish_state(esp_sleep_get_wakeup_cause());
                  id(hw_initialized) = true;

external_components:
  - source: github://landonr/lilygo-tdisplays3-esphome
    components: [tdisplays3]

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino
  flash_size: 16MB
#     build_unflags: -Werror=all
#     board_build.flash_mode: dio

preferences:
  flash_write_interval: 60min

logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret lilygos3_info_screen_esp_api_encryption_key
  on_client_connected:
    then:
      # Publish API status (used by loading animation)
      - lambda: |-
          id(api_status) = 1;
      - if:
          condition:
            lambda: return id(is_loading);
          then:
            # Hold loading animation for one more second
            - delay: 1000ms
            # Set loading animation to false
            - lambda: |-
                id(is_loading) = false;
  on_client_disconnected:
    then:
      - lambda: |-
          id(api_status) = 0;

ota:
  - platform: esphome
    password: !secret lilygos3_info_screen_esp_ota_password

packages:
  wifi: !include packages/wifi.yaml

wifi:
  fast_connect: true  
  on_connect:
    then:
      # Set WiFi status to connected (used by loading animation)
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;

captive_portal:

globals:
  # Hardware initialized flag
  - id: hw_initialized
    type: bool
    restore_value: false
    initial_value: "false"
  # Sleep mode enabled flag
  - id: sleep_mode_enabled
    type: bool
    restore_value: true
    initial_value: "false"
  # Loading animation flag
  - id: is_loading
    type: bool
    restore_value: false
    initial_value: "true"
  # WiFi status
  - id: wifi_status
    type: int
    restore_value: false
    initial_value: '0' # 0 = connecting, 1 = connected
  # Home Assistant API status
  - id: api_status
    type: int
    restore_value: false
    initial_value: '0' # 0 = connecting, 1 = connected
  # Loading animation frame
  - id: loading_anim_frame
    type: int
    restore_value: false
    initial_value: '0'

time:
  - platform: homeassistant
    id: ha_time
    timezone: Europe/Berlin
    on_time:
      # Refresh current time sensor every 10 seconds
      - seconds: 10
        then:
           - lambda: id(current_time).publish_state(id(ha_time).now().strftime("%H:%M"));
      # Refresh current date sensor every day
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - lambda: id(current_date).publish_state(id(ha_time).now().strftime("%Y-%m-%d %a"));

output:
  # Backlight brightness control
  - platform: ledc
    pin: GPIO38
    id: gpio38
    # Set priority to 400 to ensure it is initialized before on boot and interval
    setup_priority: 400
    frequency: 2000

light:
  # Backlight control
  - platform: monochromatic
    output: gpio38
    name: "Backlight brightness"
    restore_mode: RESTORE_DEFAULT_ON

# Color palette
color:
  - id: color_red
    hex: FF0000
  - id: color_white
    hex: FFFFFF
  - id: color_black
    hex: '000000'
  - id: color_green
    hex: 00FF00
  - id: color_blue
    hex: 0000FF
  - id: color_dark_blue
    hex: '000066'
  - id: color_yellow
    hex: FFFF00
  - id: color_light_yellow
    hex: FFFF99
  - id: color_gold
    hex: FAD30F
  - id: color_gray
    hex: 5E5E5E
  - id: color_braun
    hex: 8A6C66
  - id: color_cream
    hex: FFFFCC

display:
  - platform: tdisplays3
    id: disp
    # Update interval is never to ensure the display is only updated when required
    # Update performed by interval components
    update_interval: never
    rotation: 270    
    lambda: |-
      if (id(is_loading)) {
        it.fill(id(color_black));
        // Animated spinner (4 dots)
        int frame = id(loading_anim_frame);
        int cx = it.get_width()/2;
        int cy = it.get_height()/2 - 45;
        int r = 4;
        int spinner_radius = 14;
        for (int i = 0; i < 4; i++) {
          int angle = 90 * i;
          float rad = angle * 3.14159 / 180.0;
          int x = cx + cos(rad) * spinner_radius;
          int y = cy + sin(rad) * spinner_radius;
          auto color = (i == frame) ? id(color_yellow) : id(color_gray);
          it.filled_circle(x, y, r, color);
        }
        it.printf(cx, cy + 42, id(font_orbitron_16), id(color_white), TextAlign::CENTER, "Loading...");
        // WiFi status
        auto wifi_col = id(wifi_status) == 1 ? id(color_green) : id(color_yellow);
        it.printf(cx, cy + 72, id(font_roboto_16), wifi_col, TextAlign::CENTER, "WiFi: %s", id(wifi_status) == 1 ? "Connected" : "Connecting...");
        // API status
        auto api_col = id(api_status) == 1 ? id(color_green) : id(color_yellow);
        it.printf(cx, cy + 97, id(font_roboto_16), api_col, TextAlign::CENTER, "HA API: %s", id(api_status) == 1 ? "Connected" : "Connecting...");
        return;
      }

      // auto draw_battery_indicator = [](display::DisplayBuffer &it) {
      //     if (id(battery_level).has_state() && id(battery_level).state >= 0) {
      //     // Outer shell
      //     it.rectangle(it.get_width() - 55, 2, 52, 22, id(color_white));

      //     // Determine color
      //     auto bat_col = green;
      //     auto bat_text_col = yellow;
      //     auto bat_state = id(battery_level).state;

      //     if (id(charging).has_state() && id(charging).state == true) 
      //     {
      //       bat_col = id(color_blue);
      //       bat_text_col = light_yellow;
      //     } else if (bat_state < 50)
      //     { 
      //       bat_col = id(color_gold);
      //       bat_text_col = id(color_white);
      //     } else if (bat_state < 10)
      //     { 
      //       bat_col = id(color_red);
      //       bat_text_col = yellow;
      //     }

      //     // Determine width
      //     int bat_state_width = floor(id(battery_level).state / 2);

      //     if (id(charging).has_state() && id(charging).state == true && id(battery_level_charging).has_state()) {
      //       bat_state_width = floor(id(battery_level_charging).state / 2);
      //     }

      //     // Render inner section
      //     if (bat_state_width > 0 )
      //     {
      //       it.filled_rectangle(it.get_width() - 54, 3, bat_state_width, 20, bat_col);
      //     } 

      //     // Display percentage
      //     if (id(charging).has_state() && id(charging).state == true && id(battery_level_charging).has_state()) {
      //       it.printf(it.get_width() - 27, 13, id(font_roboto_16), bat_text_col, COLOR_OFF, display::TextAlign::CENTER, "%.0f%%", id(battery_level_charging).state);
      //     } else {
      //       it.printf(it.get_width() - 27, 13, id(font_roboto_16), bat_text_col, COLOR_OFF, display::TextAlign::CENTER, "%.0f%%", id(battery_level).state);
      //     }
      //   }
      // };

      // Render Battery Indicator
      // draw_battery_indicator(it);
      if (id(battery_level).has_state() && id(battery_level).state >= 0) {
        // Outer shell
        it.rectangle(it.get_width() - 55, 2, 52, 22, id(color_white));

        // Determine color
        auto bat_col = id(color_green);
        auto bat_text_col = id(color_yellow);
        auto bat_state = id(battery_level).state;

        if (id(is_charging).has_state() && id(is_charging).state == true) 
        {
          bat_col = id(color_blue);
          bat_text_col = id(color_light_yellow);
        } else if (bat_state < 50)
        { 
          bat_col = id(color_gold);
          bat_text_col = id(color_white);
        } else if (bat_state < 10)
        { 
          bat_col = id(color_red);
          bat_text_col = id(color_yellow);
        }

        // Determine width
        int bat_state_width = floor(id(battery_level).state / 2);

        // Render inner section
        if (bat_state_width > 0 )
        {
           it.filled_rectangle(it.get_width() - 54, 3, bat_state_width, 20, bat_col);
           // it.filled_rectangle(it.get_width() - 54, 3, bat_state_width, 20, id(bat_col));
        } 

        // Display percentage
        it.printf(it.get_width() - 27, 13, id(font_roboto_16), bat_text_col, COLOR_OFF, display::TextAlign::CENTER, "%.0f%%", id(battery_level).state);
      }     

      // Render WiFi Indicator
      if (id(wifi_signal_db).has_state()) {        
        // Render Outer Shells
        it.rectangle(3,17,5,5,id(color_white));
        it.rectangle(10,12,5,10,id(color_white));
        it.rectangle(16,7,5,15,id(color_white));
        it.rectangle(22,2,5,20,id(color_white));

        // Determine color and number of inner indicators
        int signal_quart = ceil(id(wifi_signal_proc).state / 25);
        auto wifi_sign_cl = id(color_green);

        switch(signal_quart){
          case 0:
          case 1: wifi_sign_cl = id(color_red); break;
          case 2: wifi_sign_cl = id(color_gold); break;
        }

        // Render inner indicators
        if (signal_quart > 0) {
          it.filled_rectangle(4,18,3,3,wifi_sign_cl);
        }

        if (signal_quart > 1) {
          it.filled_rectangle(11,13,3,8,wifi_sign_cl);
        }

        if (signal_quart > 2) {
          it.filled_rectangle(17,8,3,13,wifi_sign_cl);
        }

        if (signal_quart > 3) {
          it.filled_rectangle(23,3,3,18,wifi_sign_cl);
        }        
      }

      // Render Home Assistant API State
      auto ha_api_state_col = id(color_white);

      if (global_api_server->is_connected() == false) {
        ha_api_state_col = id(color_red);
      }

      it.image(35, 2, id(ha_api_icon), ha_api_state_col);

      // Render energy saving mode
      if (id(sleep_mode_enabled) == true) {
        it.image(62, 2, id(energy_saving_icon), id(color_green));
      }      

      // Render Temperature
      if (id(buro_temperature).has_state()) {
        it.image(105, 2, id(temp_icon));
        it.printf(125, 12, id(font_orbitron_16), id(color_white), COLOR_OFF, display::TextAlign::CENTER_LEFT, "%.1f°C", id(buro_temperature).state);
      }

      // Render Humidity
      if (id(buro_humidity).has_state()) {

        auto hum_col = id(color_white);
        int buro_h = id(buro_humidity).state;

        if (buro_h > 65 || buro_h < 50) {
           hum_col = id(color_gold);
        }

        if (buro_h > 75 || buro_h < 35) {
           hum_col = id(color_red);
        }

        it.image(190, 2, id(hum_icon), hum_col, COLOR_OFF);
        it.printf(210, 12, id(font_orbitron_16), hum_col, COLOR_OFF, display::TextAlign::CENTER_LEFT, "%.0f%%", id(buro_humidity).state);
      }

      // Render time
      auto time_col = id(color_white);

      if (
          (
           (id(ha_time).now().hour == 0 && id(ha_time).now().minute >= 30) 
           || id(ha_time).now().hour >= 1) 
           && id(ha_time).now().hour < 6) {
        time_col = id(color_red);
      }

      it.printf(2, 40, id(font_orbitron_36), time_col, id(current_time).state.c_str());
            
      // Render date        
      it.printf(2, it.get_height() - 10, id(font_orbitron_16), id(color_white), display::TextAlign::CENTER_LEFT, id(current_date).state.c_str());

      // Render waste collection

      // Render outer shells
      auto hausmull_shell_col = id(hausmull).has_state() && id(hausmull).state <= 1 ? id(color_red) : id(color_white);
      auto biomull_shell_col = id(biomull).has_state() && id(biomull).state <= 1 ? id(color_red) : id(color_white);
      auto papier_shell_col = id(papier).has_state() && id(papier).state <= 1 ? id(color_red) : id(color_white);
      auto gelbe_tonne_shell_col = id(gelbe_tonne).has_state() && id(gelbe_tonne).state <= 1 ? id(color_red) : id(color_white);

      it.rectangle(180, it.get_height() - 30, 30, 30, hausmull_shell_col);
      it.rectangle(215, it.get_height() - 30, 30, 30, biomull_shell_col);
      it.rectangle(250, it.get_height() - 30, 30, 30, papier_shell_col);
      it.rectangle(285, it.get_height() - 30, 30, 30, gelbe_tonne_shell_col);

      // Render Hausmull
      it.filled_rectangle(181, it.get_height() - 29, 28, 28, id(color_gray));

      if (id(hausmull).has_state()) {
        it.printf(195, it.get_height() - 15, id(font_orbitron_16), id(color_white), display::TextAlign::CENTER, "%.0f", id(hausmull).state);
      }

      // Render Biomull
      it.filled_rectangle(216, it.get_height() - 29, 28, 28, id(color_braun));

      if (id(biomull).has_state()) {
        it.printf(230, it.get_height() - 15, id(font_orbitron_16), id(color_cream), display::TextAlign::CENTER, "%.0f", id(biomull).state);
      }

      // Render Papier
      it.filled_rectangle(251, it.get_height() - 29, 28, 28, id(color_blue));

      if (id(papier).has_state()) {
        it.printf(265, it.get_height() - 15, id(font_orbitron_16), id(color_light_yellow), display::TextAlign::CENTER, "%.0f", id(papier).state);
      }

      // Render Gelbe Tonne
      it.filled_rectangle(286, it.get_height() - 29, 28, 28, id(color_gold));

      if (id(gelbe_tonne).has_state()) {
        it.printf(300, it.get_height() - 15, id(font_orbitron_16), id(color_dark_blue), display::TextAlign::CENTER, "%.0f", id(gelbe_tonne).state);
      }

      // Render Air Quality Icons

      // Render co2
      auto co2_col = id(color_gray);

      if (id(co2_level).has_state()) {                  
         auto co2_level_val = id(co2_level).state;
         
         if (co2_level_val == "Low") { co2_col = id(color_white); }
         if (co2_level_val == "Medium") { co2_col = id(color_yellow); }
         if (co2_level_val == "Elevated") { co2_col = id(color_gold); }
         if (co2_level_val == "High") { co2_col = id(color_red); }
         if (co2_level_val == "Extremely High") { co2_col = id(color_red); }
      }
      it.image(2, 95, id(co2_icon), co2_col, COLOR_OFF);

      // Render voc
      auto voc_col = id(color_gray);
      if (id(voc_level).has_state()) {                  
         auto voc_level_val = id(voc_level).state;
         
         if (voc_level_val == "Low") { voc_col = id(color_white); }
         if (voc_level_val == "Medium") { voc_col = id(color_yellow); }
         if (voc_level_val == "Elevated") { voc_col = id(color_gold); }
         if (voc_level_val == "High") { voc_col = id(color_red); }
         if (voc_level_val == "Extremely High") { voc_col = id(color_red); }
      }
      it.image(42, 95, id(voc_icon), voc_col, COLOR_OFF);

      // Render ppm
      auto ppm_col = id(color_gray);
      if (id(ppm_level).has_state()) {                  
         auto ppm_level_val = id(ppm_level).state;
         
         if (ppm_level_val == "Low") { ppm_col = id(color_white); }
         if (ppm_level_val == "Medium") { ppm_col = id(color_yellow); }
         if (ppm_level_val == "Elevated") { ppm_col = id(color_gold); }
         if (ppm_level_val == "High") { ppm_col = id(color_red); }
         if (ppm_level_val == "Extremely High") { ppm_col = id(color_red); }
      }
      it.image(82, 95, id(ppm_icon), ppm_col, COLOR_OFF);
   
image:
  - file: mdi:thermometer
    id: temp_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:water-percent
    id: hum_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:molecule-co2
    id: co2_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:molecule
    id: voc_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:chemical-weapon
    id: ppm_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40  
  - file: mdi:leaf
    id: energy_saving_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:home-assistant
    id: ha_api_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22

font:
  - file: "gfonts://Roboto"
    id: font_roboto_16
    size: 16
    glyphs: [
     "0123456789",
     "%.: ",
     "ConectdigWFHAPI"
     ]
  - file: "gfonts://Orbitron"
    id: font_orbitron_36
    size: 36
    bpp: 4
    glyphs: [
     "0123456789",
     ":"
     ]
  - file: "gfonts://Orbitron"
    id: font_orbitron_16
    size: 16
    bpp: 4
    glyphs: [
     "0123456789",
     "- .%°",
     "SunMoTeWdhFriatCLg"
     ]

binary_sensor:
  # Button Up
  - platform: gpio
    pin:
      number: GPIO0
      inverted: true
    name: "Button Up"
    setup_priority: 400
    on_multi_click:
      - timing:
          - ON FOR AT LEAST 500ms
        then:
          switch.toggle: backlight_on_bat
  # Button Down
  - platform: gpio
    pin:
      number: GPIO14
      allow_other_uses: true
      inverted: true
    name: "Button Down"
    setup_priority: 400  
  # Charging from cable  
  - platform: template
    id: is_charging
    name: Charging From Cable
    lambda: |-      
      return id(battery_voltage_int).has_state() && id(battery_voltage_int).state > 4.3;
  # True when it is time to go to sleep (no one is in the room or it is between 1 and 8 o'clock)
  - platform: template
    id: is_deep_sleep_time
    internal: true
    lambda: |-
      if (!id(is_charging).has_state()) {
        return {};
      }

      if (!id(pir_occupancy_last_changed_seconds).has_state()) {
        return {};
      }

      if (!id(pir_occupancy).has_state()) {
        return {};
      }

      if (!id(ha_time).now().is_valid()) {
        return {};
      }

      return id(is_charging).state == false &&
             (
               (
                id(ha_time).now().hour >= 1 && 
                id(ha_time).now().hour <= 8
               ) ||
               (
                 id(pir_occupancy_last_changed_seconds).state >= 600 && 
                 id(pir_occupancy).state == false)
             );
    on_press:
      - script.execute: manage_deep_sleep       
    on_release:      
      - script.execute: manage_deep_sleep
  # True when sleep mode is enabled (device might be still awake, displays leaf icon on screen)
  - platform: template
    id: in_power_saving_mode
    icon: mdi:leaf
    name: In power saving mode
    lambda: return id(sleep_mode_enabled) == true;
  # True when device is in deep sleep (to track in Home Assistant)
  - platform: template
    id: in_deep_sleep
    icon: mdi:sleep
    setup_priority: 350
    name: In deep sleep
    entity_category: diagnostic
  # Pir occupancy sensor
  - platform: homeassistant
    id: pir_occupancy
    entity_id: binary_sensor.buro_pir_sensor_occupancy
    internal: true
  # True when screen is on (diagnostic to track in Home Assistant)
  - platform: template
    name: Screen is On
    id: screen_is_on
    icon: mdi:television    
    lambda: return id(backlight).state || id(is_charging).state;
    entity_category: diagnostic    
text_sensor:
  # Current time sensor (to be displayed on screen)
  - platform: template
    name: "Current Time"
    id: current_time
    internal: true
    update_interval: 10sec
    lambda: return id(ha_time).now().strftime("%H:%M");
    filters:
     - lambda: |-
         static std::string last_time;
         if (x == last_time)
           return {};
         last_time = x;
         return x;
  # Current date sensor (to be displayed on screen)
  - platform: template
    name: "Current Date"
    id: current_date
    internal: true
    update_interval: 5min
    lambda: return id(ha_time).now().strftime("%Y-%m-%d %a"); 
    filters:
    - lambda: |-
        static std::string last_date;
        if (x == last_date)
          return {};
        last_date = x;
        return x;
  # VOC level sensor
  - platform: homeassistant
    id: voc_level
    entity_id: sensor.air_quality_sensor_1_voc_level
    internal: true
    filters:
    - lambda: |-
        static std::string last_voc_level;
        if (x == last_voc_level)
          return {};
        last_voc_level = x;
        return x;
  # CO2 level sensor
  - platform: homeassistant
    id: co2_level
    entity_id: sensor.air_quality_sensor_1_co2_level
    internal: true
    filters:
    - lambda: |-
        static std::string last_co2_level;
        if (x == last_co2_level)
          return {};
        last_co2_level = x;
        return x;
  # PPM level sensor
  - platform: homeassistant
    id: ppm_level
    entity_id: sensor.air_quality_sensor_1_particulate_level
    internal: true
    filters:
    - lambda: |-
        static std::string last_ppm_level;
        if (x == last_ppm_level)
          return {};
        last_ppm_level = x;
        return x;       
  # Person state sensor (to determine deep sleep duration)
  - platform: homeassistant
    id: person_state
    entity_id: person.dmitry_mokretsov
    internal: true
    filters:
    - lambda: |-
        static std::string last_person_state;
        if (x == last_person_state)
          return {};
        last_person_state = x;
        return x;          
sensor:
  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: 5s
    entity_category: diagnostic
    disabled_by_default: true
  # Internal battery voltage sensor
  - platform: adc
    id: battery_voltage_int
    name: Battery Voltage
    pin:
      number: GPIO4
    update_interval: 3sec
    unit_of_measurement: "V"
    accuracy_decimals: 2    
    state_class: measurement
    device_class: voltage
    attenuation: 12db
    internal: true
    on_value: 
      then:
        - lambda: |-
            if (!id(uptime_sensor).has_state() || id(uptime_sensor).state < 60 * 1.5) {
              return;
            }

            id(battery_voltage).publish_state(x);
    filters:      
      - multiply: 2
      # Smooth out noise
      - sliding_window_moving_average:
          window_size: 20
          send_every: 20
      - or:
        - throttle: 5min
        - delta: 0.01
  # Battery voltage sensor (to be displayed on screen and published to Home Assistant)
  - platform: template
    id: battery_voltage
    name: Battery Voltage   
    # Published by internal battery voltage sensor
    update_interval: never
    unit_of_measurement: "V"
    accuracy_decimals: 2    
    state_class: measurement
    device_class: voltage  
  # Battery level sensor (to be displayed on screen and published to Home Assistant)
  - platform: template        
    id: battery_level    
    name: Battery Charge
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    # Published by one of the internal battery level sensors
    update_interval: never
    device_class: battery
    filters:            
      - lambda: |-
         if (x > 100) return 100;
         if (x < 0) return 0;
         return x;
  # Internal battery level sensor (not charging)
  - platform: template    
    lambda: |-
      return id(battery_voltage_int).state;
    id: battery_level_int    
    name: Battery Charge
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    device_class: battery
    internal: true
    filters:      
      - calibrate_linear:
        # Values are determined by trial and error
        - 3.50 -> 0.0
        - 4.06 -> 100.0
      - or:
        - throttle: 5min
        - delta: 1
    on_value: 
      then:
        - lambda: |-
            if (!id(uptime_sensor).has_state() || id(uptime_sensor).state < 60 * 1.5) {
              return;
            }

            if (id(is_charging).state == false) {
              id(battery_level).publish_state(x);
            }
            
  # Internal battery level sensor (charging)
  - platform: template    
    lambda: |-
      return id(battery_voltage_int).state;
    id: battery_level_int_charging
    name: Battery Charging Percentage
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    device_class: battery
    internal: true
    filters:     
      # Values are determined by trial and error
      - calibrate_linear:
        - 4.63 -> 0.0
        - 4.83 -> 100.0
      - or:
        - throttle: 5min
        - delta: 1
    on_value: 
      then:
        - lambda: |-
            if (!id(uptime_sensor).has_state() || id(uptime_sensor).state < 60 * 1.5) {
              return;
            }

            if (id(is_charging).state == true) {
              id(battery_level).publish_state(x);
            }
  # WiFi signal strength/RSSI sensor (dB)
  - platform: wifi_signal
    name: "RSSI"
    id: wifi_signal_db
    update_interval: 60s
    entity_category: "diagnostic"
    unit_of_measurement: dBm
    filters: 
      - or:
        - throttle: 5min
        - delta: 1
  # WiFi signal strength/RSSI sensor (percentage)
  - platform: copy
    source_id: wifi_signal_db
    id: wifi_signal_proc
    name: "WiFi Strength"
    unit_of_measurement: "%"
    entity_category: "diagnostic"
    device_class: ""
    filters: 
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
      - or:
        - throttle: 5min
        - delta: 1
  # Buro temperature sensor
  - platform: homeassistant
    id: buro_temperature
    entity_id: sensor.temperature_sensor_buro_temperature
    unit_of_measurement: °C
    internal: true
    filters:
      - or:
        - throttle: 5min
        - delta: 0.1     
  # Buro humidity sensor
  - platform: homeassistant
    id: buro_humidity
    entity_id: sensor.temperature_sensor_buro_humidity
    unit_of_measurement: "%"
    internal: true
    filters:
      - or:
        - throttle: 5min
        - delta: 1
  # Hausmull next collection sensor
  - platform: homeassistant
    id: hausmull
    attribute: daysTo
    entity_id: sensor.hausmull_next_collection
    unit_of_measurement: d
    internal: true
    filters:
      - or:
        - throttle: 600min
        - delta: 1
  # Biomull next collection sensor
  - platform: homeassistant
    id: biomull
    attribute: daysTo
    entity_id: sensor.biomull_next_collection
    unit_of_measurement: d
    internal: true
    filters:
      - or:
        - throttle: 600min
        - delta: 1
  # Papier next collection sensor
  - platform: homeassistant
    id: papier
    attribute: daysTo
    unit_of_measurement: d
    entity_id: sensor.papier_next_collection
    internal: true
    filters:
      - or:
        - throttle: 600min
        - delta: 1
  # Gelbe Tonne next collection sensor
  - platform: homeassistant
    id: gelbe_tonne
    attribute: daysTo
    unit_of_measurement: d
    entity_id: sensor.gelbe_tonne_next_collection
    internal: true
    filters:
      - or:
        - throttle: 600min
        - delta: 1
  # Pir occupancy last changed seconds sensor
  # This sensor is used to determine if device should go to sleep when no one is in the room
  - platform: homeassistant
    id: pir_occupancy_last_changed_seconds
    entity_id: sensor.buro_pir_sensor_occupancy_last_changed_seconds
    unit_of_measurement: s
    internal: true
    filters:
      - or:
        - throttle: 5min
        - delta: 60
  # Wakeup cause sensor  
  - platform: template
    name: "Wakeup Cause"
    id: wakeup_cause
    accuracy_decimals: 0
    lambda: return esp_sleep_get_wakeup_cause();
    entity_category: diagnostic
    filters:
      - or:
        - throttle: 5min
        - delta: 1
switch:
  # Backlight switch
  - platform: gpio    
    pin:
      number: GPIO15
      mode:
        output: true
    id: backlight
    icon: mdi:television
    # Restore backlight state to off on boot. Going to be enabled by interval component when nessesary
    restore_mode: ALWAYS_OFF
  # Backlight setting for battery powered mode
  # This is used to keep the backlight on when the device is on battery
  - platform: template
    id: backlight_on_bat
    name: Backlight When On Battery
    icon: mdi:television
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

# Deep sleep configuration
deep_sleep:
  id: deep_sleep_1
  esp32_ext1_wakeup:
    pins:
      # Wakeup pin - lower button
      - number: GPIO14
        allow_other_uses: true
    mode: ALL_LOW

# Script to manage deep sleep
script:
  - id: manage_deep_sleep
    then:
      - wait_until:
          wifi.connected:
      - wait_until:
          api.connected:
      - wait_until:
          lambda: |-
            return id(pir_occupancy_last_changed_seconds).has_state();
      - wait_until:
          lambda: |-
            return id(wakeup_cause).has_state();
      - wait_until:
          lambda: |-
            return id(is_deep_sleep_time).has_state();
      - if:
          condition:
            binary_sensor.is_on: is_deep_sleep_time
          then:        
            - lambda: id(sleep_mode_enabled) = true;      
            - logger.log: "initiating sleep mode"            
            - if:
                condition:
                   lambda: return id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER;                  
                then:                  
                  - logger.log: "device will go in deep sleep in 60 seconds if conditions still met"
                  # Wait for 60 seconds when wakeup cause is not timer (e.g. button press)
                  - delay: 60sec
                else: 
                   - logger.log: "device will go in deep sleep now if conditions still met"
            - if:
                condition:
                  binary_sensor.is_on: is_deep_sleep_time
                then:            
                  # Set sleep duration
                  - script.execute: set_sleep_duration
                  # Publish nessesary states
                  - lambda: |-
                      id(in_deep_sleep).publish_state(true);
                  - switch.turn_off: backlight
                  - lambda: |-
                      id(screen_is_on).publish_state(false);
                  - logger.log: "entering deep sleep"            
                  # Enter deep sleep
                  - deep_sleep.enter:
                      id: deep_sleep_1
                else:
                - lambda: id(sleep_mode_enabled) = false;            
                - logger.log: "sleeping conditions are not met anymore, sleep has been cancelled"           
          else:  
            # Prevent deep sleep
            - deep_sleep.prevent:
                id: deep_sleep_1
            - logger.log: "disabling sleep mode"
            - lambda: id(sleep_mode_enabled) = false;
            - logger.log: "sleep mode has been disabled"
  - id: set_sleep_duration
    then:
      - lambda: |-
                // auto now = id(ha_time).now();
                // auto target_time = now;

                // // Set target time to 08:00:00 using ESPTime's members.
                // target_time.hour = 8;
                // target_time.minute = 0;
                // target_time.second = 0;

                // // Recalculate the timestamp for the modified ESPTime object.
                // target_time.recalc_timestamp_local();  // or recalc_timestamp_utc() based on your requirements.

                // // If the target time today has already passed, add a day.
                // if (now.timestamp >= target_time.timestamp) {
                //   const time_t one_day_sec = 3600 * 24;
                //   target_time.timestamp += one_day_sec;
                // }

                // // Calculate sleep duration in milliseconds.
                // uint32_t sleep_duration = (target_time.timestamp - now.timestamp) * 1000;
                // ESP_LOGD("sleep", "Estimated sleep duration: %d", sleep_duration);

                // // Set the sleep duration for deep sleep.
                // id(deep_sleep_1).set_sleep_duration(sleep_duration);
                
                // default sleep duration is five minutes
                uint32_t sleep_duration = 60 * 5 * 1000;

                // if not occupied for thirty minutes
                if (id(pir_occupancy_last_changed_seconds).state >= 60*30) {
                  sleep_duration = 60 * 10 * 1000;
                }

                // if not occupied for one hour
                if (id(pir_occupancy_last_changed_seconds).state >= 60*60) {
                  sleep_duration = 60 * 20 * 1000;
                }

                // if not occupied for two hours
                if (id(pir_occupancy_last_changed_seconds).state >= 60*60*2) {
                  sleep_duration = 60 * 30 * 1000;
                }

                // if not occupied for four hours
                if (
                  id(pir_occupancy_last_changed_seconds).state >= 60*60*4
                  || id(person_state).state != "home"
                  ) 
                {
                  sleep_duration = 60 * 60 * 1000;
                }

                // If night sleep calculate overnight sleep duration instead
                if (id(ha_time).now().hour >= 1 && id(ha_time).now().hour <= 8) {
                  // Get the current time from ha_time
                  auto now = id(ha_time).now();

                  // Convert the ESPTime 'now' to a standard C tm structure.
                  struct tm target_tm = now.to_c_tm();
                
                  // Update the target time to 08:00:00.
                  target_tm.tm_hour = 8;
                  target_tm.tm_min  = 0;
                  target_tm.tm_sec  = 0;

                  // Compute a new timestamp from the adjusted tm.
                  time_t target_timestamp = mktime(&target_tm);

                  // If today's target time has passed, add one day (86400 seconds).
                  if (now.timestamp >= target_timestamp) {
                    const time_t one_day_sec = 3600 * 24;
                    target_timestamp += one_day_sec;
                  }

                  // Calculate sleep duration in milliseconds.
                  sleep_duration = (target_timestamp - now.timestamp) * 1000;

                  auto max_sleep_duration_ms = 60 * 60 * 1000;

                  // limit sleep duration to one hour to avoid waking up issues
                  if (sleep_duration > max_sleep_duration_ms) {
                    sleep_duration = max_sleep_duration_ms;
                  }
                }

                ESP_LOGD("sleep", "Estimated sleep duration: %d", sleep_duration);

                // Set the sleep duration.
                id(deep_sleep_1).set_sleep_duration(sleep_duration);
    
interval:
  - interval: 300ms
    setup_priority: 275
    id: loading_anim
    then:
      # Update loading animation 
      - if: 
          condition:
            # Update loading animation if device is loading and sleep mode is disabled or wakeup cause is not timer
            lambda: return id(is_loading) && (id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER);
          then:                      
            - lambda: |-
                id(loading_anim_frame) = (id(loading_anim_frame) + 1) % 4;
            - component.update: disp
  - interval: 1s
    setup_priority: 275
    id: charging_update
    then:
      # Wait for hardware to be initialized (see on boot) and wakeup cause to be set
      - wait_until:
          lambda: return id(hw_initialized);
      - wait_until:
          lambda: |-
            return id(wakeup_cause).has_state();
      # ================================================================
      - if: 
          condition:
            lambda: return id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER;
          then:        
            # Turn on backlight if it is off after wakeup from deep sleep
            - if:
                condition:
                  lambda: return id(backlight).state != id(backlight_on_bat).state;
                then:
                  - switch.toggle:
                      id: backlight       
            # Update display if device is charging
            - if:
                condition:
                  lambda: return id(is_charging).state && !id(is_loading);
                then: 
                  - component.update: disp
  - interval: 5s    
    setup_priority: 275
    id: battery_update
    then:
      # Update display if device is not charging (on battery)
      - if: 
          condition:
            lambda: return !id(is_charging).state && !id(is_loading) && (id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER);
          then:                        
            - component.update: disp
    