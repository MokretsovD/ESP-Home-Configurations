---
substitutions:
  device_static_ip: !secret lilygos3_info_screen_wifi_manual_ip_static_ip
  device_ap_ssid: !secret lilygos3_info_screen_wifi_ap_ssid
  device_ap_password: !secret lilygos3_info_screen_wifi_ap_password
  wifi_ssid: !secret wifi_ssid
  wifi_password: !secret wifi_password
  wifi_manual_ip_gateway: !secret wifi_manual_ip_gateway
  wifi_manual_ip_subnet: !secret wifi_manual_ip_subnet

  # configuration variables ================================
  # system =================================================
  flash_write_interval: 60min

  # boot ===================================================
  interval_priority: "275"
  boot_script_priority: "300"
  deep_sleep_priority: "350"
  peripherals_boot_priority: "400"

  # display ================================================
  loading_anim_duration: 1000ms
  # clock
  clock_time_sensor_update_cron: "/5 * * * * *"
  clock_time_update_interval: "10sec"
  clock_date_sensor_update_cron: "0 0 0 * * *"
  clock_date_update_interval: "5min"

  # battery
  charging_voltage_threshold_v: "4.15"
  battery_threshold_yellow: "50"
  battery_threshold_red: "10"
  battery_voltage_spike_threshold_v: "0.06"

  # Battery calibration values
  battery_level_int_min_v: "3.6"
  battery_level_int_max_v: "4.06"
  battery_level_int_charging_min_v: "4.63"
  battery_level_int_charging_max_v: "4.83"

  # occupancy
  occupancy_step_1_threshold_sec: "60 * 2" # two minutes
  occupancy_step_2_threshold_sec: "60 * 5" # five minutes
  occupancy_step_3_threshold_sec: "60 * 10" # ten minutes

  # humidity
  humidity_upper_threshold_yellow: "65"
  humidity_lower_threshold_yellow: "50"
  humidity_upper_threshold_red: "75"
  humidity_lower_threshold_red: "35"

  # deepsleep ==============================================
  deepsleep_delay: "60sec"
  # deep sleep night mode, sleep from 1am to 8am
  deepsleep_night_sleep_start_hour: "1"
  deepsleep_night_sleep_end_hour: "8"
  # deepsleep absence threshold
  deepsleep_absence_threshold_sec: "60 * 15" # fifteen minutes

  # deepsleep durations
  deepsleep_default_duration_ms: "60 * 5 * 1000" # five minutes
  deepsleep_step_1_duration_ms: "60 * 10 * 1000" # ten minutes
  deepsleep_step_2_duration_ms: "60 * 20 * 1000" # twenty minutes
  deepsleep_step_3_duration_ms: "60 * 30 * 1000" # thirty minutes
  deepsleep_step_4_duration_ms: "60 * 60 * 1000" # one hour
  deepsleep_max_duration_ms: "60 * 60 * 1000 * 2" # two hours

  # deepsleep absence thresholds
  deepsleep_step_1_threshold_sec: "60*30" # thirty minutes
  deepsleep_step_2_threshold_sec: "60*60" # one hour
  deepsleep_step_3_threshold_sec: "60*60*2" # two hours
  deepsleep_step_4_threshold_sec: "60*60*4" # four hours

  # sensors ===============================================
  uptime_update_interval: 60s
  # occupancy sensors
  pir_occupancy_sensor_id: binary_sensor.buro_pir_sensor_occupancy
  pir_occupancy_last_changed_sensor_id: sensor.buro_pir_sensor_occupancy_last_changed_seconds
  # air quality sensors
  air_quality_voc_level_sensor_id: sensor.air_quality_sensor_1_voc_level
  air_quality_co2_level_sensor_id: sensor.air_quality_sensor_1_co2_level
  air_quality_ppm_level_sensor_id: sensor.air_quality_sensor_1_particulate_level

  # person sensor
  person_sensor_id: person.dmitry_mokretsov

  # temperature sensor
  temperature_sensor_id: sensor.temperature_sensor_buro_temperature

  # humidity sensor
  humidity_sensor_id: sensor.temperature_sensor_buro_humidity

  # waste collection sensors
  hausmull_sensor_id: sensor.hausmull_next_collection
  biomull_sensor_id: sensor.biomull_next_collection
  papier_sensor_id: sensor.papier_next_collection
  gelbe_tonne_sensor_id: sensor.gelbe_tonne_next_collection

  # weather
  outdoor_temperature_sensor_id: sensor.gw1100a_outdoor_temperature
  wind_beaufort_sensor_id: sensor.wind_beaufort_recent_max
  rain_index_sensor_id: sensor.gw1100a_rain_index_3_recent_max
  rain_rate_sensor_id: sensor.gw1100a_rain_rate
  lighting_strike_distance_sensor_id: sensor.lighting_strike_distance_recent_min

esphome:
  name: lilygos3-info-screen
  friendly_name: lilygos3-info-screen
  platformio_options:
    board_build.f_flash: 80000000L
    board_build.partitions: default_16MB.csv
    board_build.arduino.memory_type: qio_opi
  on_boot:
    # priority has been determined by trial and error
    # it should be lower than gpio components and higher than interval components
    - priority: ${boot_script_priority}
      # publish required states on boot
      then:
        - lambda: |-
            id(in_deep_sleep).publish_state(false);                  
            id(wakeup_cause).publish_state(esp_sleep_get_wakeup_cause());
            id(hw_initialized) = true;

external_components:
  - source: github://landonr/lilygo-tdisplays3-esphome
    components: [tdisplays3]

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: arduino
  flash_size: 16MB
#     build_unflags: -Werror=all
#     board_build.flash_mode: dio

preferences:
  flash_write_interval: ${flash_write_interval}

logger:

# Enable Home Assistant API
api:
  encryption:
    key: !secret lilygos3_info_screen_esp_api_encryption_key
  on_client_connected:
    then:
      # Publish API status (used by loading animation)
      - lambda: |-
          id(api_status) = 1;
      - if:
          condition:
            lambda: return id(is_loading);
          then:
            # Wait for WiFi signal to be available
            - wait_until:
                lambda: return id(wifi_signal_db).has_state();
            # Hold loading animation for one more second
            - delay: ${loading_anim_duration}
            # Set loading animation to false
            - lambda: |-
                id(is_loading) = false;
  on_client_disconnected:
    then:
      - lambda: |-
          id(api_status) = 0;

ota:
  - platform: esphome
    password: !secret lilygos3_info_screen_esp_ota_password

packages:
  wifi: !include packages/wifi.yaml
  wifi-signal-sensors: !include packages/wifi-signal-sensors.yaml
  factory-reset-button: !include packages/factory-reset-button.yaml

wifi:
  fast_connect: true
  on_connect:
    then:
      # Set WiFi status to connected (used by loading animation)
      - lambda: |-
          id(wifi_status) = 1;
  on_disconnect:
    then:
      - lambda: |-
          id(wifi_status) = 0;

captive_portal:

globals:
  # Hardware initialized flag
  - id: hw_initialized
    type: bool
    restore_value: false
    initial_value: "false"
  # Sleep mode enabled flag
  - id: sleep_mode_enabled
    type: bool
    restore_value: true
    initial_value: "false"
  # Loading animation flag
  - id: is_loading
    type: bool
    restore_value: false
    initial_value: "true"
  # WiFi status
  - id: wifi_status
    type: int
    restore_value: false
    initial_value: "0" # 0 = connecting, 1 = connected
  # Home Assistant API status
  - id: api_status
    type: int
    restore_value: false
    initial_value: "0" # 0 = connecting, 1 = connected
  # Loading animation frame
  - id: loading_anim_frame
    type: int
    restore_value: false
    initial_value: "0"
  - id: last_battery_voltage
    type: float
    restore_value: false
    initial_value: "0"
  - id: sleep_duration_ms
    type: long
    restore_value: no
    initial_value: ${deepsleep_default_duration_ms}

time:
  - platform: homeassistant
    id: ha_time
    timezone: Europe/Berlin
    on_time:
      # Refresh current time sensor every ${clock_time_sensor_update_cron}
      - cron: ${clock_time_sensor_update_cron}
        then:
          - lambda: id(current_time).publish_state(id(ha_time).now().strftime("%H:%M"));
      # Refresh current date sensor every ${clock_date_sensor_update_cron}
      - cron: ${clock_date_sensor_update_cron}
        then:
          - lambda: id(current_date).publish_state(id(ha_time).now().strftime("%Y-%m-%d %a"));

output:
  # Backlight brightness control
  - platform: ledc
    pin: GPIO38
    id: gpio38
    # Set priority to ${peripherals_boot_priority} to ensure it is initialized before on boot and interval
    setup_priority: ${peripherals_boot_priority}
    frequency: 2000

light:
  # Backlight control
  - platform: monochromatic
    output: gpio38
    name: "Backlight brightness"
    restore_mode: RESTORE_DEFAULT_ON

# Color palette
color:
  - id: color_red
    hex: FF0000
  - id: color_white
    hex: FFFFFF
  - id: color_black
    hex: "000000"
  - id: color_green
    hex: 00FF00
  - id: color_corporate_blue
    hex: 4EC5F1
  - id: color_blue_700
    hex: 1976D2
  - id: color_blue
    hex: 0000FF
  - id: color_dark_blue
    hex: "000066"
  - id: color_yellow
    hex: FFFF00
  - id: color_light_yellow
    hex: FFFF99
  - id: color_gold
    hex: FAD30F
  - id: color_gray
    hex: 5E5E5E
  - id: color_braun
    hex: 8A6C66
  - id: color_cream
    hex: FFFFCC

display:
  - platform: tdisplays3
    id: disp
    # Update interval is never to ensure the display is only updated when required
    # Update performed by interval components
    update_interval: never
    rotation: 270
    lambda: |-
      auto render_loading_screen = [](display::Display &it) {     
        if (!id(is_loading)) {
          return;
        }

        it.fill(id(color_black));
        // Animated spinner (4 dots)
        int frame = id(loading_anim_frame);
        int cx = it.get_width()/2;
        int cy = it.get_height()/2 - 45;
        int r = 4;
        int spinner_radius = 14;
        for (int i = 0; i < 4; i++) {
          int angle = 90 * i;
          float rad = angle * 3.14159 / 180.0;
          int x = cx + cos(rad) * spinner_radius;
          int y = cy + sin(rad) * spinner_radius;
          auto color = (i == frame) ? id(color_yellow) : id(color_gray);
          it.filled_circle(x, y, r, color);
        }
        it.printf(cx, cy + 42, id(font_orbitron_16), id(color_white), TextAlign::CENTER, "Loading...");
        // WiFi status
        auto wifi_col = id(wifi_status) == 1 ? id(color_green) : id(color_yellow);
        it.printf(cx, cy + 72, id(font_roboto_16), wifi_col, TextAlign::CENTER, "WiFi: %s", id(wifi_status) == 1 ? "Connected" : "Connecting...");
        // API status
        auto api_col = id(api_status) == 1 ? id(color_green) : id(color_yellow);
        it.printf(cx, cy + 97, id(font_roboto_16), api_col, TextAlign::CENTER, "HA API: %s", id(api_status) == 1 ? "Connected" : "Connecting...");
      };

      auto render_battery_indicator = [](display::Display &it) {
        if (!id(battery_level).has_state() || id(battery_level).state < 0) {
          return;
        }
        
        // Outer shell
        it.rectangle(it.get_width() - 55, 2, 52, 22, id(color_white));

        // Determine color
        auto bat_col = id(color_green);
        auto bat_text_col = id(color_yellow);
        auto bat_state = id(battery_level).state;

        if (id(is_charging).has_state() && id(is_charging).state == true) 
        {
          bat_col = id(color_blue);
          bat_text_col = id(color_light_yellow);
        } else if (bat_state < ${battery_threshold_yellow})
        { 
          bat_col = id(color_gold);
          bat_text_col = id(color_white);
        } else if (bat_state < ${battery_threshold_red})
        { 
          bat_col = id(color_red);
          bat_text_col = id(color_yellow);
        }

        // Determine width
        int bat_state_width = floor(id(battery_level).state / 2);

        // Render inner section
        if (bat_state_width > 0 )
        {
           it.filled_rectangle(it.get_width() - 54, 3, bat_state_width, 20, bat_col);
           // it.filled_rectangle(it.get_width() - 54, 3, bat_state_width, 20, id(bat_col));
        } 

        // Display percentage
        it.printf(it.get_width() - 27, 13, id(font_roboto_16), bat_text_col, COLOR_OFF, display::TextAlign::CENTER, "%.0f%%", id(battery_level).state);        
      };

      auto render_wifi_indicator = [](display::Display &it) {
        if (!id(wifi_signal_db).has_state() || id(wifi_status) == 0) {
          it.image(3, 2, id(wifi_strength_alert_icon), id(color_red));
          return;
        }                
        
        // Determine color and icon
        int signal_quart = id(wifi_signal_quart).state;

        // Render inner indicators
        if (signal_quart > 3) {
          it.image(3, 2, id(wifi_strength_4_icon), id(color_green));
        } else if (signal_quart > 2) {
          it.image(3, 2, id(wifi_strength_3_icon), id(color_green));
        } else if (signal_quart > 1) {
          it.image(3, 2, id(wifi_strength_2_icon), id(color_gold));
        } else if (signal_quart > 0) {
          it.image(3, 2, id(wifi_strength_1_icon), id(color_red));
        } else if (signal_quart == 0) {
          it.image(3, 2, id(wifi_strength_outline_icon), id(color_red));
        }      
      };

      auto render_ha_api_indicator = [](display::Display &it) {
        // Render Home Assistant API State
        auto ha_api_state_col = id(color_white);

        if (global_api_server->is_connected() == false) {
          ha_api_state_col = id(color_red);
        }

        it.image(30, 2, id(ha_api_icon), ha_api_state_col);
      };

      auto render_energy_saving_mode = [](display::Display &it) {      
        it.image(58, 2, id(energy_saving_icon), id(color_green));
      };

      auto render_pir_occupancy = [](display::Display &it) {
        if (!id(pir_occupancy).has_state() || id(pir_occupancy).state == true) {
          return;
        }

        int last_changed_secs = floor(id(pir_occupancy_last_changed_seconds).state);
        
        auto r_c = 255;        
        auto g_c = max(min(510 - last_changed_secs, 255), 0);
        auto b_c = max(255 - last_changed_secs, 0);

        auto icon = id(run_icon);

        if (id(pir_occupancy_last_changed_seconds).state > ${occupancy_step_3_threshold_sec}) {
          icon = id(human_walker_icon);
        } else if (id(pir_occupancy_last_changed_seconds).state > ${occupancy_step_2_threshold_sec}) {
          icon = id(human_cane_icon);
        } else if (id(pir_occupancy_last_changed_seconds).state > ${occupancy_step_1_threshold_sec}) {
          icon = id(walk_icon);
        } 

        it.image(58, 2, icon, Color(r_c, g_c, b_c));
      };

      auto render_temperature = [](display::Display &it) {
        if (!id(room_temperature).has_state() || isnan(id(room_temperature).state)) {
          // Show icon and N/A if value is not available or not a number
          it.image(105, 2, id(temp_icon), id(color_white), COLOR_OFF);
          it.printf(125, 12, id(font_orbitron_16), id(color_white), COLOR_OFF, display::TextAlign::CENTER_LEFT, "N/A");
          return;
        }

        auto temp = id(room_temperature).state;

        // Calculate color based on temperature
        int r = 255, g = 255, b = 255; // default white
        if (temp <= 16) {
          r = 0; g = 0; b = 255;
        } else if (temp > 16 && temp < 20) {
          // Blue to white
          float t = (temp - 16) / 4.0f; // 0 at 16, 1 at 20
          r = g = (int)(255 * t);
          b = 255;
        } else if (temp >= 20 && temp <= 23) {
          r = g = b = 255;
        } else if (temp > 23 && temp <= 26) {
          // White to yellow (white to (255,255,0))
          float t = (temp - 23) / 3.0f; // 0 at 23, 1 at 26
          r = g = 255;
          b = (int)(255 * (1.0f - t));
        } else if (temp > 26 && temp < 30) {
          // Yellow (255,255,0) to Red (255,0,0)
          float t = (temp - 26) / 4.0f; // 0 at 26, 1 at 30
          r = 255;
          g = (int)(255 * (1.0f - t));
          b = 0;
        } else if (temp >= 30) {
          r = 255; g = 0; b = 0;
        }

        it.image(105, 2, id(temp_icon), Color(r, g, b), COLOR_OFF);
        it.printf(125, 12, id(font_orbitron_16), Color(r, g, b), COLOR_OFF, display::TextAlign::CENTER_LEFT, "%.1f째C", temp);
      };

      auto render_humidity = [](display::Display &it) {
        if (!id(room_humidity).has_state() || isnan(id(room_humidity).state)) {
          // Show icon and N/A if value is not available or not a number
          it.image(190, 2, id(hum_icon), id(color_white), COLOR_OFF);
          it.printf(210, 12, id(font_orbitron_16), id(color_white), COLOR_OFF, display::TextAlign::CENTER_LEFT, "N/A");
          return;
        }

        auto hum_col = id(color_white);

        if (id(room_humidity).state > ${humidity_upper_threshold_red} || id(room_humidity).state < ${humidity_lower_threshold_red}) {
           hum_col = id(color_red);
        } else if (id(room_humidity).state > ${humidity_upper_threshold_yellow} || id(room_humidity).state < ${humidity_lower_threshold_yellow}) {
           hum_col = id(color_gold);
        }

        it.image(190, 2, id(hum_icon), hum_col, COLOR_OFF);
        it.printf(210, 12, id(font_orbitron_16), hum_col, COLOR_OFF, display::TextAlign::CENTER_LEFT, "%.0f%%", id(room_humidity).state);      
      };

      auto render_time = [](display::Display &it) {
        auto time_col = id(color_white);

        if (
            (
             (id(ha_time).now().hour == 0 && id(ha_time).now().minute >= 30) 
             || id(ha_time).now().hour >= 1) 
             && id(ha_time).now().hour < 6) {
          time_col = id(color_red);
        } else if (id(ha_time).now().hour == 0 && id(ha_time).now().minute < 30) {
          time_col = id(color_gold);
        }

        it.printf(2, 40, id(font_orbitron_36), time_col, id(current_time).state.c_str());
      };

      auto render_date = [](display::Display &it) {
        it.printf(2, it.get_height() - 10, id(font_orbitron_16), id(color_white), display::TextAlign::CENTER_LEFT, id(current_date).state.c_str());
      };


      auto render_hausmull = [](display::Display &it) {      
        //Render outer shell
        auto hausmull_shell_col = id(hausmull).has_state() && id(hausmull).state <= 1 ? id(color_red) : id(color_white);
        it.rectangle(180, it.get_height() - 30, 30, 30, hausmull_shell_col);

        it.filled_rectangle(181, it.get_height() - 29, 28, 28, id(color_gray));

        // Render value
        if (id(hausmull).has_state()) {
          it.printf(195, it.get_height() - 15, id(font_orbitron_16), id(color_white), display::TextAlign::CENTER, "%.0f", id(hausmull).state);
        }
      };

      auto render_biomull = [](display::Display &it) {
        // Render outer shell
        auto biomull_shell_col = id(biomull).has_state() && id(biomull).state <= 1 ? id(color_red) : id(color_white);
        it.rectangle(215, it.get_height() - 30, 30, 30, biomull_shell_col);

        it.filled_rectangle(216, it.get_height() - 29, 28, 28, id(color_braun));

        // Render value
        if (id(biomull).has_state()) {
          it.printf(230, it.get_height() - 15, id(font_orbitron_16), id(color_cream), display::TextAlign::CENTER, "%.0f", id(biomull).state);
        }
      };

      auto render_papier = [](display::Display &it) {
        // Render outer shell
        auto papier_shell_col = id(papier).has_state() && id(papier).state <= 1 ? id(color_red) : id(color_white);
        it.rectangle(250, it.get_height() - 30, 30, 30, papier_shell_col);

        it.filled_rectangle(251, it.get_height() - 29, 28, 28, id(color_blue));

        // Render value
        if (id(papier).has_state()) {
          it.printf(265, it.get_height() - 15, id(font_orbitron_16), id(color_light_yellow), display::TextAlign::CENTER, "%.0f", id(papier).state);
        }        
      };

      auto render_gelbe_tonne = [](display::Display &it) {
        // Render outer shell
        auto gelbe_tonne_shell_col = id(gelbe_tonne).has_state() && id(gelbe_tonne).state <= 1 ? id(color_red) : id(color_white);
        it.rectangle(285, it.get_height() - 30, 30, 30, gelbe_tonne_shell_col);

        it.filled_rectangle(286, it.get_height() - 29, 28, 28, id(color_gold));

        // Render value
        if (id(gelbe_tonne).has_state()) {
          it.printf(300, it.get_height() - 15, id(font_orbitron_16), id(color_dark_blue), display::TextAlign::CENTER, "%.0f", id(gelbe_tonne).state);
        }
      };

      auto render_waste_collection = [&render_hausmull, &render_biomull, &render_papier, &render_gelbe_tonne](display::Display &it) {
        render_hausmull(it);
        render_biomull(it);
        render_papier(it);
        render_gelbe_tonne(it);
      };

      auto render_co2 = [](display::Display &it) {
        auto co2_col = id(color_gray);

        if (id(co2_level).has_state()) {
          auto co2_level_val = id(co2_level).state;
          
          if (co2_level_val == "Low") {
            co2_col = id(color_white);
          } else if (co2_level_val == "Medium") {
            co2_col = id(color_yellow);
          } else if (co2_level_val == "Elevated") {
            co2_col = id(color_gold);
          } else if (co2_level_val == "High" || co2_level_val == "Extremely High") {
            co2_col = id(color_red);
          }
        }

        it.image(2, 95, id(co2_icon), co2_col, COLOR_OFF);
      };

      auto render_voc = [](display::Display &it) {
        auto voc_col = id(color_gray);
        if (id(voc_level).has_state()) {
          auto voc_level_val = id(voc_level).state;
          
          if (voc_level_val == "Low") {
            voc_col = id(color_white);
          } else if (voc_level_val == "Medium") {
            voc_col = id(color_yellow);
          } else if (voc_level_val == "Elevated") {
            voc_col = id(color_gold);
          } else if (voc_level_val == "High" || voc_level_val == "Extremely High") {
            voc_col = id(color_red);
          }
        }
        it.image(42, 95, id(voc_icon), voc_col, COLOR_OFF);
      };

      auto render_ppm = [](display::Display &it) {
        auto ppm_col = id(color_gray);
        if (id(ppm_level).has_state()) {                  
           auto ppm_level_val = id(ppm_level).state;
           
           if (ppm_level_val == "Low") {
            ppm_col = id(color_white);
           } else if (ppm_level_val == "Medium") {
            ppm_col = id(color_yellow);
           } else if (ppm_level_val == "Elevated") {
            ppm_col = id(color_gold);
           } else if (ppm_level_val == "High" || ppm_level_val == "Extremely High") {
            ppm_col = id(color_red);
           }
        }
        it.image(82, 95, id(ppm_icon), ppm_col, COLOR_OFF);
      };

      auto render_air_quality = [&render_co2, &render_voc, &render_ppm](display::Display &it) {
        render_co2(it);
        render_voc(it);
        render_ppm(it);
      };

      // Helper to calculate icon position based on alarm number (0-7)
      auto get_alarm_icon_position = [](int alarm_num) -> std::pair<int, int> {
        // 4 icons per row, 2 rows
        int icons_per_row = 4;
        int icon_spacing_x = 48; // horizontal spacing between icons
        int icon_spacing_y = 48; // vertical spacing between rows
        int icon_size = 40;      // icon size (for centering)
        int start_x = 142;       // leftmost x position
        int start_y = 40;        // y position of first row
        int row = alarm_num / icons_per_row;
        int col = alarm_num % icons_per_row;
        int x = start_x + col * icon_spacing_x;
        int y = start_y + row * icon_spacing_y;
        return {x, y};
      };

      auto render_rain_index_alert = [&get_alarm_icon_position](display::Display &it, int alarm_num) -> bool {
        static int last_alarm_num = -1;
        static std::pair<int, int> last_position;
        static float last_rain_index = -1000.0f;
        static uint8_t last_r = 0, last_g = 0, last_b = 0;

        // Update icon position only if alarm_num changes
        if (alarm_num != last_alarm_num) {
          last_position = get_alarm_icon_position(alarm_num);
          last_alarm_num = alarm_num;
        }

        if (id(rain_index).has_state() && id(rain_index).state >= 1.2) {
          float val = id(rain_index).state;
          // Update color only if rain_index changes
          if (val != last_rain_index) {
            if (val >= 2.5) {
              last_r = 255; last_g = 0; last_b = 0;
            } else if (val >= 1.85) {
              float t = (val - 1.85) / (2.5 - 1.85);
              last_r = 255;
              last_g = 255 * (1.0f - t);
              last_b = 0;
            } else {
              float t = (val - 1.2) / (1.85 - 1.2);
              last_r = 255;
              last_g = 255;
              last_b = 255 * (1.0f - t);
            }
            last_rain_index = val;
          }
          it.image(last_position.first, last_position.second, id(weather_pouring_icon), Color(last_r, last_g, last_b), COLOR_OFF);
          return true;
        }
        return false;
      };

      auto render_heat_alarm = [&get_alarm_icon_position](display::Display &it, int alarm_num) -> bool {
        static int last_alarm_num = -1;
        static std::pair<int, int> last_position;
        static float last_outdoor_temp = -1000.0f;
        static int last_result = -1; // 0: false, 1: true
        static esphome::Color last_color;
        static int last_icon = 0;

        if (alarm_num != last_alarm_num) {
          last_position = get_alarm_icon_position(alarm_num);
          last_alarm_num = alarm_num;
        }

        if (id(outdoor_temperature).has_state()) {
          auto outdoor_temp = id(outdoor_temperature).state;
          bool result = outdoor_temp < 0 || outdoor_temp > 27;
          if (outdoor_temp != last_outdoor_temp || result != last_result) {
            if (outdoor_temp <= -10) {
              last_color = id(color_blue_700);
              last_icon = 1;
            } else if (outdoor_temp < 0) {
              last_color = id(color_corporate_blue);
              last_icon = 1;
            } else if (outdoor_temp > 32) {
              last_color = id(color_red);
              last_icon = 2;
            } else if (outdoor_temp > 27) {
              last_color = id(color_yellow);
              last_icon = 2;
            }
            last_outdoor_temp = outdoor_temp;
            last_result = result;
          }
          if (result) {
            if (last_icon == 1) {
              it.image(last_position.first, last_position.second, id(snowflake_alert_icon), last_color, COLOR_OFF);
            } else if (last_icon == 2) {
              it.image(last_position.first, last_position.second, id(sun_thermometer_icon), last_color, COLOR_OFF);
            }
          }
          return result;
        }
        return false;
      };

      auto render_wind_alert = [&get_alarm_icon_position](display::Display &it, int alarm_num) -> bool {
        static int last_alarm_num = -1;
        static std::pair<int, int> last_position;
        static float last_bft = -1000.0f;
        static esphome::Color last_color;
        if (alarm_num != last_alarm_num) {
          last_position = get_alarm_icon_position(alarm_num);
          last_alarm_num = alarm_num;
        }
        if (id(wind_beaufort).has_state()) {
          float bft = id(wind_beaufort).state;
          if (bft != last_bft) {
            last_color = id(color_white);
            if (bft >= 6) {
              last_color = id(color_red);
            } else if (bft >= 5) {
              last_color = id(color_yellow);
            }
            last_bft = bft;
          }
          if (bft >= 4) {
            it.image(last_position.first, last_position.second, id(wind_icon), last_color, COLOR_OFF);
            return true;
          }
        }
        return false;
      };

      auto render_rain_rate_alert = [&get_alarm_icon_position](display::Display &it, int alarm_num) -> bool {
        static int last_alarm_num = -1;
        static std::pair<int, int> last_position;
        static float last_val = -1000.0f;
        static uint8_t last_r = 0, last_g = 0, last_b = 0;
        if (alarm_num != last_alarm_num) {
          last_position = get_alarm_icon_position(alarm_num);
          last_alarm_num = alarm_num;
        }
        if (id(rain_rate).has_state() && id(rain_rate).state > 0) {
          float val = id(rain_rate).state;
          if (val != last_val) {
            if (val >= 8.0) {
              last_r = 0; last_g = 0; last_b = 255;
            } else {
              float t = val / 8.0f;
              last_r = 200 * (1.0f - t);
              last_g = 220 * (1.0f - t);
              last_b = 255;
            }
            last_val = val;
          }
          it.image(last_position.first, last_position.second, id(weather_pouring_icon), Color(last_r, last_g, last_b), COLOR_OFF);
          return true;
        }
        return false;
      };

      auto render_lightning_alert = [&get_alarm_icon_position](display::Display &it, int alarm_num) -> bool {
        static int last_alarm_num = -1;
        static std::pair<int, int> last_position;
        static float last_val = -1000.0f;
        static uint8_t last_r = 0, last_g = 0, last_b = 0;
        if (alarm_num != last_alarm_num) {
          last_position = get_alarm_icon_position(alarm_num);
          last_alarm_num = alarm_num;
        }
        if (id(lightning_strike_distance).has_state() && id(lightning_strike_distance).state < 18) {
          float val = id(lightning_strike_distance).state;
          if (val != last_val) {
            float t = val / 18.0f;
            last_r = 255;
            last_g = 255 * t;
            last_b = 0;
            last_val = val;
          }
          it.image(last_position.first, last_position.second, id(weather_lightning_rainy_icon), Color(last_r, last_g, last_b), COLOR_OFF);
          return true;
        }
        return false;
      };

      auto render_rain_alarm = [&render_rain_rate_alert, &render_lightning_alert, &render_rain_index_alert](display::Display &it, int alarm_num) -> bool {
        // 1. Rain rate takes highest priority
        if (render_rain_rate_alert(it, alarm_num)) return true;

        // 2. Lightning distance
        if (render_lightning_alert(it, alarm_num)) return true;

        // 3. Rain index
        if (render_rain_index_alert(it, alarm_num)) return true;

        return false;
      };

      auto render_alarms = [&render_heat_alarm, &render_wind_alert, &render_rain_alarm](display::Display &it) {
        // List of alarm lambdas to call in order
        std::vector<std::function<bool(display::Display&, int)>> alarm_renderers = {
          render_heat_alarm,
          render_wind_alert,
          render_rain_alarm
        };
        int alarm_num = 0;
        for (auto &render_alarm : alarm_renderers) {
          if (render_alarm(it, alarm_num)) {
            alarm_num++;
          }
        }
      };

      auto render_layout = [](display::Display &it) {
        it.line(0, 30, it.get_width(), 30, id(color_white));
        it.line(0, it.get_height() - 24, 160, it.get_height() - 24, id(color_white));
        it.line(180, it.get_height() - 38, it.get_width(), it.get_height() - 38, id(color_white));
        it.line(160, it.get_height() - 24, 180, it.get_height() - 38, id(color_white));
      };

      auto render_main_content = [
        &render_layout,
        &render_battery_indicator,
        &render_wifi_indicator, 
        &render_ha_api_indicator, 
        &render_energy_saving_mode, 
        &render_pir_occupancy, 
        &render_temperature, 
        &render_humidity, 
        &render_time, 
        &render_date, 
        &render_waste_collection, 
        &render_air_quality, 
        &render_alarms](display::Display &it) {
        if (id(is_loading)) {          
          return;
        }

        render_layout(it);

        render_battery_indicator(it);
        render_wifi_indicator(it);
        render_ha_api_indicator(it);

        if (id(sleep_mode_enabled) == true) {
          render_energy_saving_mode(it);
        } else {
          render_pir_occupancy(it);
        }

        render_temperature(it);
        render_humidity(it);
        render_time(it);            
        render_date(it);

        render_waste_collection(it);
        render_air_quality(it);

        render_alarms(it);
      };

      render_loading_screen(it);
      render_main_content(it);

image:
  - file: mdi:thermometer
    id: temp_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:water-percent
    id: hum_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:molecule-co2
    id: co2_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:molecule
    id: voc_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:chemical-weapon
    id: ppm_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:leaf
    id: energy_saving_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:home-assistant
    id: ha_api_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:run
    id: run_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:walk
    id: walk_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:human-cane
    id: human_cane_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:human-walker
    id: human_walker_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-alert-outline
    id: wifi_strength_alert_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-outline
    id: wifi_strength_outline_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-4
    id: wifi_strength_4_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-3
    id: wifi_strength_3_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-2
    id: wifi_strength_2_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:wifi-strength-1
    id: wifi_strength_1_icon
    type: grayscale
    transparency: alpha_channel
    resize: 22x22
  - file: mdi:sun-thermometer
    id: sun_thermometer_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:snowflake-alert
    id: snowflake_alert_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:weather-windy
    id: wind_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:weather-pouring
    id: weather_pouring_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40
  - file: mdi:weather-lightning-rainy
    id: weather_lightning_rainy_icon
    type: grayscale
    transparency: alpha_channel
    resize: 40x40

font:
  - file: "gfonts://Roboto"
    id: font_roboto_16
    size: 16
    glyphs: ["0123456789", "%.: ", "ConectdigWFHAPI"]
  - file: "gfonts://Orbitron"
    id: font_orbitron_36
    size: 36
    bpp: 4
    glyphs: ["0123456789", ":"]
  - file: "gfonts://Orbitron"
    id: font_orbitron_16
    size: 16
    bpp: 4
    glyphs: ["0123456789", "- .%째/", "SunMoTeWdhFriatCLgNA"]

binary_sensor:
  # Button Up
  - platform: gpio
    pin:
      number: GPIO0
      inverted: true
    name: "Button Up"
    setup_priority: ${peripherals_boot_priority}
    on_multi_click:
      - timing:
          - ON FOR AT LEAST 500ms
        then:
          switch.toggle: backlight_on_bat
  # Button Down
  - platform: gpio
    pin:
      number: GPIO14
      allow_other_uses: true
      inverted: true
    name: "Button Down"
    setup_priority: ${peripherals_boot_priority}
  # Charging from cable
  - platform: template
    id: is_charging
    name: Charging From Cable
    lambda: |-
      return id(battery_voltage_int).has_state() && id(battery_voltage_int).state > ${charging_voltage_threshold_v};
  # True when it is time to go to sleep (no one is in the room or it is between 1 and 8 o'clock)
  - platform: template
    id: is_deep_sleep_time
    internal: true
    lambda: |-
      if (!id(is_charging).has_state()) {
        return {};
      }

      if (!id(pir_occupancy_last_changed_seconds).has_state()) {
        return {};
      }

      if (!id(pir_occupancy).has_state()) {
        return {};
      }

      if (!id(ha_time).now().is_valid()) {
        return {};
      }

      return id(is_charging).state == false &&
             (
               (
                id(ha_time).now().hour >= ${deepsleep_night_sleep_start_hour} && 
                id(ha_time).now().hour <= ${deepsleep_night_sleep_end_hour}
               ) ||
               (
                 id(pir_occupancy_last_changed_seconds).state >= ${deepsleep_absence_threshold_sec} && 
                 id(pir_occupancy).state == false)
             );
    on_press:
      - script.execute: manage_deep_sleep
    on_release:
      - script.execute: manage_deep_sleep
  # True when sleep mode is enabled (device might be still awake, displays leaf icon on screen)
  - platform: template
    id: in_power_saving_mode
    icon: mdi:leaf
    name: In power saving mode
    lambda: return id(sleep_mode_enabled) == true;
  # True when device is in deep sleep (to track in Home Assistant)
  - platform: template
    id: in_deep_sleep
    icon: mdi:sleep
    setup_priority: ${deep_sleep_priority}
    name: In deep sleep
    entity_category: diagnostic
  # Pir occupancy sensor
  - platform: homeassistant
    id: pir_occupancy
    entity_id: ${pir_occupancy_sensor_id}
    internal: true
  # True when screen is on (diagnostic to track in Home Assistant)
  - platform: template
    name: Screen is On
    id: screen_is_on
    icon: mdi:television
    lambda: return id(backlight).state || id(is_charging).state;
    entity_category: diagnostic
text_sensor:
  # Current time sensor (to be displayed on screen)
  - platform: template
    name: "Current Time"
    id: current_time
    internal: true
    update_interval: ${clock_time_update_interval}
    lambda: return id(ha_time).now().strftime("%H:%M");
    filters:
      - lambda: |-
          static std::string last_time;
          if (x == last_time)
            return {};
          last_time = x;
          return x;
  # Current date sensor (to be displayed on screen)
  - platform: template
    name: "Current Date"
    id: current_date
    internal: true
    update_interval: ${clock_date_update_interval}
    lambda: return id(ha_time).now().strftime("%Y-%m-%d %a");
    filters:
      - lambda: |-
          static std::string last_date;
          if (x == last_date)
            return {};
          last_date = x;
          return x;
  # VOC level sensor
  - platform: homeassistant
    id: voc_level
    entity_id: ${air_quality_voc_level_sensor_id}
    internal: true
    filters:
      - lambda: |-
          static std::string last_voc_level;
          if (x == last_voc_level)
            return {};
          last_voc_level = x;
          return x;
  # CO2 level sensor
  - platform: homeassistant
    id: co2_level
    entity_id: ${air_quality_co2_level_sensor_id}
    internal: true
    filters:
      - lambda: |-
          static std::string last_co2_level;
          if (x == last_co2_level)
            return {};
          last_co2_level = x;
          return x;
  # PPM level sensor
  - platform: homeassistant
    id: ppm_level
    entity_id: ${air_quality_ppm_level_sensor_id}
    internal: true
    filters:
      - lambda: |-
          static std::string last_ppm_level;
          if (x == last_ppm_level)
            return {};
          last_ppm_level = x;
          return x;
  # Person state sensor (to determine deep sleep duration)
  - platform: homeassistant
    id: person_state
    entity_id: ${person_sensor_id}
    internal: true
    filters:
      - lambda: |-
          static std::string last_person_state;
          if (x == last_person_state)
            return {};
          last_person_state = x;
          return x;

sensor:
  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: ${uptime_update_interval}
    entity_category: diagnostic
    disabled_by_default: true
  # Internal battery voltage sensor
  - platform: adc
    id: battery_voltage_int
    name: Battery Voltage
    pin:
      number: GPIO4
    update_interval: 2sec
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state_class: measurement
    device_class: voltage
    attenuation: 12db
    internal: true
    on_value:
      then:
        - lambda: |-
            id(battery_voltage).publish_state(x);
    filters:
      - skip_initial: 10 #20
      - multiply: 2
      - lambda: |-
          auto last_battery_voltage_value = id(last_battery_voltage);

          if (x >= ${charging_voltage_threshold_v} && x < ${battery_level_int_charging_min_v}) {
            return last_battery_voltage_value;
          }

          bool is_voltage_spike = abs(x - last_battery_voltage_value) >= ${battery_voltage_spike_threshold_v};
          id(last_battery_voltage) = x;

          if (is_voltage_spike) {
            return last_battery_voltage_value > 0 ? last_battery_voltage_value : x;
          }

          return x;
      # Smooth out noise
      - sliding_window_moving_average:
          window_size: 20
          send_every: 5
      - or:
          - throttle: 5min
          - delta: 0.01
  # Battery voltage sensor (to be displayed on screen and published to Home Assistant)
  - platform: template
    id: battery_voltage
    name: Battery Voltage
    # Published by internal battery voltage sensor
    update_interval: never
    unit_of_measurement: "V"
    accuracy_decimals: 2
    state_class: measurement
    device_class: voltage
  # Battery level sensor (to be displayed on screen and published to Home Assistant)
  - platform: template
    id: battery_level
    name: Battery Charge
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    # Published by one of the internal battery level sensors
    update_interval: never
    device_class: battery
    filters:
      - clamp:
          min_value: 0
          max_value: 100
  # Internal battery level sensor (not charging)
  - platform: copy
    source_id: battery_voltage_int
    id: battery_level_int
    name: Battery Charge
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    device_class: battery
    internal: true
    filters:
      - skip_initial: 1
      - calibrate_linear:
          - ${battery_level_int_min_v} -> 0.0
          - ${battery_level_int_max_v} -> 100.0
      - or:
          - throttle: 5min
          - delta: 1
    on_value:
      then:
        - lambda: |-
            if (id(is_charging).state == false) {
              id(battery_level).publish_state(x);
            }

  # Internal battery level sensor (charging)
  - platform: copy
    source_id: battery_voltage_int
    id: battery_level_int_charging
    name: Battery Charging Percentage
    unit_of_measurement: "%"
    accuracy_decimals: 0
    state_class: measurement
    device_class: battery
    internal: true
    filters:
      - skip_initial: 1
      # Values are determined by trial and error
      - calibrate_linear:
          - ${battery_level_int_charging_min_v} -> 0.0
          - ${battery_level_int_charging_max_v} -> 100.0
      - or:
          - throttle: 5min
          - delta: 1
    on_value:
      then:
        - lambda: |-
            if (id(is_charging).state == true ) {
              id(battery_level).publish_state(x);
            }
  # WiFi signal quartile sensor (for display logic)
  - platform: copy
    source_id: wifi_signal_proc
    id: wifi_signal_quart
    name: "WiFi Signal Quartile"
    unit_of_measurement: "quartile"
    accuracy_decimals: 0
    internal: true
    #  update_interval: 60s
    filters:
      - lambda: return ceil(x / 25.0);
      - delta: 1
  # Temperature sensor
  - platform: homeassistant
    id: room_temperature
    entity_id: ${temperature_sensor_id}
    unit_of_measurement: 째C
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Humidity sensor
  - platform: homeassistant
    id: room_humidity
    entity_id: ${humidity_sensor_id}
    unit_of_measurement: "%"
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 1
  # Hausmull next collection sensor
  - platform: homeassistant
    id: hausmull
    attribute: daysTo
    entity_id: ${hausmull_sensor_id}
    unit_of_measurement: d
    internal: true
    filters:
      - or:
          - throttle: 600min
          - delta: 1
  # Biomull next collection sensor
  - platform: homeassistant
    id: biomull
    attribute: daysTo
    entity_id: ${biomull_sensor_id}
    unit_of_measurement: d
    internal: true
    filters:
      - or:
          - throttle: 600min
          - delta: 1
  # Papier next collection sensor
  - platform: homeassistant
    id: papier
    attribute: daysTo
    unit_of_measurement: d
    entity_id: ${papier_sensor_id}
    internal: true
    filters:
      - or:
          - throttle: 600min
          - delta: 1
  # Gelbe Tonne next collection sensor
  - platform: homeassistant
    id: gelbe_tonne
    attribute: daysTo
    unit_of_measurement: d
    entity_id: ${gelbe_tonne_sensor_id}
    internal: true
    filters:
      - or:
          - throttle: 600min
          - delta: 1
  # Pir occupancy last changed seconds sensor
  # This sensor is used to determine if device should go to sleep when no one is in the room
  - platform: homeassistant
    id: pir_occupancy_last_changed_seconds
    entity_id: ${pir_occupancy_last_changed_sensor_id}
    unit_of_measurement: s
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 10
  # Outdoor temperature sensor
  - platform: homeassistant
    id: outdoor_temperature
    entity_id: ${outdoor_temperature_sensor_id}
    unit_of_measurement: 째C
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Wind beaufort sensor from Home Assistant
  - platform: homeassistant
    id: wind_beaufort
    entity_id: ${wind_beaufort_sensor_id}
    unit_of_measurement: "Bft"
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 1
  # Wakeup cause sensor
  - platform: template
    name: "Wakeup Cause"
    id: wakeup_cause
    accuracy_decimals: 0
    lambda: return esp_sleep_get_wakeup_cause();
    entity_category: diagnostic
    filters:
      - or:
          - throttle: 5min
          - delta: 1
    # Next wake up time (approximate)
  - platform: template
    name: "Next Wake Up Time"
    id: next_wake_up_time
    internal: false
    # unit_of_measurement: "ms"
    accuracy_decimals: 0
    state_class: measurement
    device_class: timestamp
    entity_category: diagnostic
    update_interval: never
  # Rain index sensor from Home Assistant
  - platform: homeassistant
    id: rain_index
    entity_id: ${rain_index_sensor_id}
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Rain rate sensor from Home Assistant
  - platform: homeassistant
    id: rain_rate
    entity_id: ${rain_rate_sensor_id}
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 0.1
  # Lightning strike distance sensor from Home Assistant
  - platform: homeassistant
    id: lightning_strike_distance
    entity_id: ${lighting_strike_distance_sensor_id}
    internal: true
    filters:
      - or:
          - throttle: 5min
          - delta: 1

switch:
  # Backlight switch
  - platform: gpio
    pin:
      number: GPIO15
      mode:
        output: true
    id: backlight
    icon: mdi:television
    # Restore backlight state to off on boot. Going to be enabled by interval component when nessesary
    restore_mode: ALWAYS_OFF
  # Backlight setting for battery powered mode
  # This is used to keep the backlight on when the device is on battery
  - platform: template
    id: backlight_on_bat
    name: Backlight When On Battery
    icon: mdi:television
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

# Deep sleep configuration
deep_sleep:
  id: deep_sleep_1
  esp32_ext1_wakeup:
    pins:
      # Wakeup pin - lower button
      - number: GPIO14
        allow_other_uses: true
    mode: ALL_LOW

# Script to manage deep sleep
script:
  - id: manage_deep_sleep
    then:
      - wait_until:
          wifi.connected:
      - wait_until:
          api.connected:
      - wait_until:
          lambda: |-
            return id(pir_occupancy_last_changed_seconds).has_state();
      - wait_until:
          lambda: |-
            return id(wakeup_cause).has_state();
      - wait_until:
          lambda: |-
            return id(is_deep_sleep_time).has_state();
      - if:
          condition:
            binary_sensor.is_on: is_deep_sleep_time
          then:
            - lambda: id(sleep_mode_enabled) = true;
            - logger.log: "initiating sleep mode"
            - if:
                condition:
                  lambda: return id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER;
                then:
                  - logger.log: "device will go in deep sleep in ${deepsleep_delay} if conditions still met"
                  # Wait for 60 seconds when wakeup cause is not timer (e.g. button press)
                  - delay: ${deepsleep_delay}
                else:
                  - logger.log: "device will go in deep sleep now if conditions still met"
            - if:
                condition:
                  binary_sensor.is_on: is_deep_sleep_time
                then:
                  # Set sleep duration
                  - script.execute: set_sleep_duration
                  # Publish next wake up timestamp
                  - lambda: |-
                      auto now = id(ha_time).now();
                      uint32_t sleep_duration = id(sleep_duration_ms);
                      time_t wakeup_timestamp = now.timestamp + (sleep_duration / 1000);
                      id(next_wake_up_time).publish_state(wakeup_timestamp);
                  # Publish nessesary states
                  - lambda: |-
                      id(in_deep_sleep).publish_state(true);
                  - switch.turn_off: backlight
                  - lambda: |-
                      id(screen_is_on).publish_state(false);
                  - logger.log: "entering deep sleep"
                  - delay: 500ms
                  # Enter deep sleep
                  - deep_sleep.enter:
                      id: deep_sleep_1
                else:
                  - deep_sleep.prevent:
                      id: deep_sleep_1
                  - lambda: id(sleep_mode_enabled) = false;
                  - logger.log: "sleeping conditions are not met anymore, sleep has been cancelled"
          else:
            # Prevent deep sleep
            - deep_sleep.prevent:
                id: deep_sleep_1
            - logger.log: "disabling sleep mode"
            - lambda: id(sleep_mode_enabled) = false;
            - logger.log: "sleep mode has been disabled"
  - id: set_sleep_duration
    then:
      - lambda: |-
          // auto now = id(ha_time).now();
          // auto target_time = now;

          // // Set target time to 08:00:00 using ESPTime's members.
          // target_time.hour = 8;
          // target_time.minute = 0;
          // target_time.second = 0;

          // // Recalculate the timestamp for the modified ESPTime object.
          // target_time.recalc_timestamp_local();  // or recalc_timestamp_utc() based on your requirements.

          // // If the target time today has already passed, add a day.
          // if (now.timestamp >= target_time.timestamp) {
          //   const time_t one_day_sec = 3600 * 24;
          //   target_time.timestamp += one_day_sec;
          // }

          // // Calculate sleep duration in milliseconds.
          // uint32_t sleep_duration = (target_time.timestamp - now.timestamp) * 1000;
          // ESP_LOGD("sleep", "Estimated sleep duration: %d", sleep_duration);

          // // Set the sleep duration for deep sleep.
          // id(deep_sleep_1).set_sleep_duration(sleep_duration);

          // default sleep duration is five minutes
          uint32_t sleep_duration = ${deepsleep_default_duration_ms};

          // if not occupied for thirty minutes
          if (id(pir_occupancy_last_changed_seconds).state >= ${deepsleep_step_1_threshold_sec}) {
            sleep_duration = ${deepsleep_step_1_duration_ms};
          }

          // if not occupied for one hour
          if (id(pir_occupancy_last_changed_seconds).state >= ${deepsleep_step_2_threshold_sec}) {
            sleep_duration = ${deepsleep_step_2_duration_ms};
          }

          // if not occupied for two hours
          if (id(pir_occupancy_last_changed_seconds).state >= ${deepsleep_step_3_threshold_sec}) {
            sleep_duration = ${deepsleep_step_3_duration_ms};
          }

          // if not occupied for four hours
          if (
            id(pir_occupancy_last_changed_seconds).state >= ${deepsleep_step_4_threshold_sec}
            || id(person_state).state != "home"
            ) 
          {
            sleep_duration = ${deepsleep_step_4_duration_ms};
          }

          // If night sleep calculate overnight sleep duration instead
          if (id(ha_time).now().hour >= ${deepsleep_night_sleep_start_hour} && id(ha_time).now().hour <= ${deepsleep_night_sleep_end_hour}) {
            // Get the current time from ha_time
            auto now = id(ha_time).now();

            // Convert the ESPTime 'now' to a standard C tm structure.
            struct tm target_tm = now.to_c_tm();

            // Update the target time to 08:00:00.
            target_tm.tm_hour = 8;
            target_tm.tm_min  = 0;
            target_tm.tm_sec  = 0;

            // Compute a new timestamp from the adjusted tm.
            time_t target_timestamp = mktime(&target_tm);

            // If today's target time has passed, add one day (86400 seconds).
            if (now.timestamp >= target_timestamp) {
              const time_t one_day_sec = 3600 * 24;
              target_timestamp += one_day_sec;
            }

            // Calculate sleep duration in milliseconds.
            sleep_duration = (target_timestamp - now.timestamp) * 1000;

            auto max_sleep_duration_ms = ${deepsleep_max_duration_ms};

            // limit sleep duration to deepsleep_max_duration_ms to avoid waking up issues
            if (sleep_duration > max_sleep_duration_ms) {
              sleep_duration = max_sleep_duration_ms;
            }
          }

          ESP_LOGD("sleep", "Estimated sleep duration: %d", sleep_duration);

          id(sleep_duration_ms) = sleep_duration;
          // Set the sleep duration.
          id(deep_sleep_1).set_sleep_duration(sleep_duration);

interval:
  - interval: 300ms
    setup_priority: ${interval_priority}
    id: loading_anim
    then:
      # Update loading animation
      - if:
          condition:
            # Update loading animation if device is loading and sleep mode is disabled or wakeup cause is not timer
            lambda: return id(is_loading) && (id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER);
          then:
            - lambda: |-
                id(loading_anim_frame) = (id(loading_anim_frame) + 1) % 4;
            - component.update: disp
  - interval: 1s
    setup_priority: ${interval_priority}
    id: charging_update
    then:
      # Wait for hardware to be initialized (see on boot) and wakeup cause to be set
      - wait_until:
          lambda: return id(hw_initialized);
      - wait_until:
          lambda: |-
            return id(wakeup_cause).has_state();
      - if:
          condition:
            lambda: return id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER;
          then:
            # Turn on backlight if it is off after wakeup from deep sleep
            - if:
                condition:
                  lambda: return id(backlight).state != id(backlight_on_bat).state;
                then:
                  - switch.toggle:
                      id: backlight
            # Update display if device is charging
            - if:
                condition:
                  lambda: return id(is_charging).state && !id(is_loading);
                then:
                  - component.update: disp
  - interval: 5s
    setup_priority: ${interval_priority}
    id: battery_update
    then:
      # Update display if device is not charging (on battery)
      - if:
          condition:
            lambda: return !id(is_charging).state && !id(is_loading) && (id(sleep_mode_enabled) == false || id(wakeup_cause).state != ESP_SLEEP_WAKEUP_TIMER);
          then:
            - component.update: disp
